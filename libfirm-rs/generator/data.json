[
    {
      "__module__": "__main__",
      "initattrs": [
        {
          "comment": "",
          "fqname": "exc.pinned",
          "init": "op_pin_state_pinned",
          "name": "pinned",
          "to_flags": null,
          "type": "int",
          "noprop": false
        }
      ],
      "__is_firm_op": true,
      "ins": [{ "comment": "memory dependency", "name": "mem" }],
      "arity": "variable",
      "input_name": "input",
      "attrs": [
        {
          "comment": "number of constraints",
          "fqname": "n_constraints",
          "init": null,
          "name": "n_constraints",
          "to_flags": null,
          "type": "size_t",
          "noprop": true
        },
        {
          "comment": "constraints",
          "fqname": "constraints",
          "init": null,
          "name": "constraints",
          "to_flags": null,
          "type": "ir_asm_constraint*",
          "noprop": false
        },
        {
          "comment": "number of clobbered registers/memory",
          "fqname": "n_clobbers",
          "init": null,
          "name": "n_clobbers",
          "to_flags": null,
          "type": "size_t",
          "noprop": true
        },
        {
          "comment": "list of clobbered registers/memory",
          "fqname": "clobbers",
          "init": null,
          "name": "clobbers",
          "to_flags": null,
          "type": "ident**",
          "noprop": false
        },
        {
          "comment": "assembler text",
          "fqname": "text",
          "init": null,
          "name": "text",
          "to_flags": null,
          "type": "ident*",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "pinned_init": "op_pin_state_pinned",
      "attrs_name": "assem",
      "outs": [
        { "comment": "memory result", "name": "M" },
        { "comment": "first output", "name": "first_out" }
      ],
      "name": "ASM",
      "doc": "executes assembler fragments of the target machine.\n\nThe node contains a template for an assembler snippet. The compiler will\nreplace occurrences of %0 to %9 with input/output registers,\n%% with a single % char. Some backends allow additional specifiers (for\nexample %w3, %l3, %h3 on x86 to get a 16bit, 8hit low, 8bit high part\nof a register).\nAfter the replacements the text is emitted into the final assembly.\n\nThe clobber list contains names of registers which have an undefined value\nafter the assembler instruction is executed; it may also contain 'memory'\nor 'cc' if global state/memory changes or the condition code registers\n(some backends implicitly set cc, memory clobbers on all ASM statements).\n\nExample (an i386 instruction)::\n\n    ASM(text=\"btsl %1, %0\",\n        constraints = [\"=m\", \"r\"],\n        clobbers = [\"cc\"])\n\nAs there are no output, the %0 references the first input which is just an\naddress which the asm operation writes to. %1 references to an input which\nis passed as a register. The condition code register has an unknown value\nafter the instruction.\n\n(This format is inspired by the gcc extended asm syntax)",
      "attr_struct": "asm_attr",
      "pinned": "exception",
      "flags": ["keep", "uses_memory"],
      "mode": "mode_T",
      "constructor": false,
      "__doc__": "executes assembler fragments of the target machine.\n\n    The node contains a template for an assembler snippet. The compiler will\n    replace occurrences of %0 to %9 with input/output registers,\n    %% with a single % char. Some backends allow additional specifiers (for\n    example %w3, %l3, %h3 on x86 to get a 16bit, 8hit low, 8bit high part\n    of a register).\n    After the replacements the text is emitted into the final assembly.\n\n    The clobber list contains names of registers which have an undefined value\n    after the assembler instruction is executed; it may also contain 'memory'\n    or 'cc' if global state/memory changes or the condition code registers\n    (some backends implicitly set cc, memory clobbers on all ASM statements).\n\n    Example (an i386 instruction)::\n\n        ASM(text=\"btsl %1, %0\",\n            constraints = [\"=m\", \"r\"],\n            clobbers = [\"cc\"])\n\n    As there are no output, the %0 references the first input which is just an\n    address which the asm operation writes to. %1 references to an input which\n    is passed as a register. The condition code register has an unknown value\n    after the instruction.\n\n    (This format is inspired by the gcc extended asm syntax)\n    ",
      "serializer": false,
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "size of additional inputs array",
          "fqname": "arity",
          "init": null,
          "name": "arity",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "additional inputs",
          "fqname": "in",
          "init": null,
          "name": "in",
          "to_flags": null,
          "type": "ir_node *const *",
          "noprop": false
        },
        {
          "comment": "number of constraints",
          "fqname": "n_constraints",
          "init": null,
          "name": "n_constraints",
          "to_flags": null,
          "type": "size_t",
          "noprop": true
        },
        {
          "comment": "constraints",
          "fqname": "constraints",
          "init": null,
          "name": "constraints",
          "to_flags": null,
          "type": "ir_asm_constraint*",
          "noprop": false
        },
        {
          "comment": "number of clobbered registers/memory",
          "fqname": "n_clobbers",
          "init": null,
          "name": "n_clobbers",
          "to_flags": null,
          "type": "size_t",
          "noprop": true
        },
        {
          "comment": "list of clobbered registers/memory",
          "fqname": "clobbers",
          "init": null,
          "name": "clobbers",
          "to_flags": null,
          "type": "ident**",
          "noprop": false
        },
        {
          "comment": "assembler text",
          "fqname": "text",
          "init": null,
          "name": "text",
          "to_flags": null,
          "type": "ident*",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "name": "Add",
      "doc": "returns the sum of its operands",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "add",
      "arity": 2,
      "flags": ["commutative"],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the sum of its operands",
      "serializer": true,
      "mode": "get_irn_mode(mode_is_reference(get_irn_mode(irn_right)) ? irn_right : irn_left)"
    },
    {
      "__module__": "__main__",
      "name": "Address",
      "doc": "Symbolic constant that represents the address of an entity (variable or\nmethod)",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": 0,
      "serializer": true,
      "mode": "mode_P",
      "usesGraph": true,
      "__doc__": "Symbolic constant that represents the address of an entity (variable or\n    method)",
      "block": "get_irg_start_block(irg)",
      "arguments": [
        {
          "comment": "entity to operate on",
          "fqname": "entity",
          "init": null,
          "name": "entity",
          "to_flags": null,
          "type": "ir_entity*",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "name": "Align",
      "doc": "A symbolic constant that represents the alignment of a type",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": 0,
      "arguments": [
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        },
        {
          "comment": "type to operate on",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        }
      ],
      "usesGraph": true,
      "__doc__": "A symbolic constant that represents the alignment of a type",
      "block": "get_irg_start_block(irg)",
      "serializer": true
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "memory dependency", "name": "mem" },
        { "comment": "size of the block in bytes", "name": "size" }
      ],
      "arity": 2,
      "attrs": [
        {
          "comment": "alignment of the memory block (must be a power of 2)",
          "fqname": "alignment",
          "init": null,
          "name": "alignment",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        }
      ],
      "pinned": "yes",
      "outs": [
        { "comment": "memory result", "name": "M" },
        { "comment": "pointer to newly allocated memory", "name": "res" }
      ],
      "name": "Alloc",
      "doc": "Allocates a block of memory on the stack.",
      "attr_struct": "alloc_attr",
      "attrs_name": "alloc",
      "flags": ["uses_memory", "const_memory"],
      "usesGraph": false,
      "mode": "mode_T",
      "__doc__": "Allocates a block of memory on the stack.",
      "serializer": true,
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "size",
          "fqname": "irn_size",
          "init": null,
          "name": "irn_size",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "alignment of the memory block (must be a power of 2)",
          "fqname": "alignment",
          "init": null,
          "name": "alignment",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "block the end node belongs to", "name": "end_block" },
        { "comment": "block the start node belongs to", "name": "start_block" },
        { "comment": "end node of this ir_graph", "name": "end" },
        { "comment": "start node of this ir_graph", "name": "start" },
        { "comment": "frame of this ir_graph", "name": "frame" },
        { "comment": "initial memory of this ir_graph", "name": "initial_mem" },
        { "comment": "argument proj of the start node", "name": "args" },
        { "comment": "the only NoMem node of this ir_graph", "name": "no_mem" }
      ],
      "arity": 8,
      "usesGraph": false,
      "singleton": true,
      "pinned": "yes",
      "name": "Anchor",
      "doc": "Utility node used to \"hold\" nodes in a graph that might possibly not be\nreachable by other means or which should be reachable immediately without\nsearching through the graph.\nEach firm-graph contains exactly one anchor node whose address is always\nknown. All other well-known graph-nodes like Start, End, NoMem, ...\nare found by looking at the respective Anchor operand.",
      "attrs_name": "anchor",
      "flags": ["dump_noblock"],
      "mode": "mode_ANY",
      "constructor": false,
      "__doc__": "Utility node used to \"hold\" nodes in a graph that might possibly not be\n    reachable by other means or which should be reachable immediately without\n    searching through the graph.\n    Each firm-graph contains exactly one anchor node whose address is always\n    known. All other well-known graph-nodes like Start, End, NoMem, ...\n    are found by looking at the respective Anchor operand.",
      "serializer": false,
      "arguments": [
        {
          "comment": "end_block",
          "fqname": "irn_end_block",
          "init": null,
          "name": "irn_end_block",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "start_block",
          "fqname": "irn_start_block",
          "init": null,
          "name": "irn_start_block",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "end",
          "fqname": "irn_end",
          "init": null,
          "name": "irn_end",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "start",
          "fqname": "irn_start",
          "init": null,
          "name": "irn_start",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "frame",
          "fqname": "irn_frame",
          "init": null,
          "name": "irn_frame",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "initial_mem",
          "fqname": "irn_initial_mem",
          "init": null,
          "name": "irn_initial_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "args",
          "fqname": "irn_args",
          "init": null,
          "name": "irn_args",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "no_mem",
          "fqname": "irn_no_mem",
          "init": null,
          "name": "irn_no_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "name": "And",
      "doc": "returns the result of a bitwise and operation of its operands",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "and",
      "arity": 2,
      "flags": ["commutative"],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the result of a bitwise and operation of its operands",
      "serializer": true,
      "mode": "get_irn_mode(irn_left)"
    },
    {
      "pinned": "yes",
      "__module__": "__main__",
      "name": "Bad",
      "doc": "Bad nodes indicate invalid input, which is values which should never be\ncomputed.\n\nThe typical use case for the Bad node is removing unreachable code.\nFrontends should set the current_block to Bad when it is clear that\nfollowing code must be unreachable (i.e. after a goto or return statement).\nOptimizations also set block predecessors to Bad when it becomes clear,\nthat a control flow edge can never be executed.\n\nThe gigo optimizations ensures that nodes with Bad as their block, get\nreplaced by Bad themselves. Nodes with at least 1 Bad input get exchanged\nwith Bad too. Exception to this rule are Block, Phi, Tuple and End node;\nThis is because removing inputs from a Block is hairy operation (requiring,\nPhis to be shortened too for example). So instead of removing block inputs\nthey are set to Bad, and the actual removal is left to the control flow\noptimization phase. Block, Phi, Tuple with only Bad inputs however are\nreplaced by Bad right away.\n\nIn the future we may use the Bad node to model poison values that arise\nfrom undefined behaviour like reading uninitialized local variables in C.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "attrs_name": "bad",
      "arity": 0,
      "flags": ["start_block", "dump_noblock"],
      "arguments": [
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        }
      ],
      "usesGraph": true,
      "__doc__": "\n    Bad nodes indicate invalid input, which is values which should never be\n    computed.\n\n    The typical use case for the Bad node is removing unreachable code.\n    Frontends should set the current_block to Bad when it is clear that\n    following code must be unreachable (i.e. after a goto or return statement).\n    Optimizations also set block predecessors to Bad when it becomes clear,\n    that a control flow edge can never be executed.\n\n    The gigo optimizations ensures that nodes with Bad as their block, get\n    replaced by Bad themselves. Nodes with at least 1 Bad input get exchanged\n    with Bad too. Exception to this rule are Block, Phi, Tuple and End node;\n    This is because removing inputs from a Block is hairy operation (requiring,\n    Phis to be shortened too for example). So instead of removing block inputs\n    they are set to Bad, and the actual removal is left to the control flow\n    optimization phase. Block, Phi, Tuple with only Bad inputs however are\n    replaced by Bad right away.\n\n    In the future we may use the Bad node to model poison values that arise\n    from undefined behaviour like reading uninitialized local variables in C.\n    ",
      "block": "get_irg_start_block(irg)",
      "serializer": true
    },
    {
      "__module__": "__main__",
      "name": "Bitcast",
      "doc": "Converts a value between modes with different arithmetics but same\nnumber of bits by reinterpreting the bits in the new mode",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "operand", "name": "op" }],
      "attrs_name": "bitcast",
      "arity": 1,
      "flags": [],
      "usesGraph": false,
      "__doc__": "Converts a value between modes with different arithmetics but same\n    number of bits by reinterpreting the bits in the new mode",
      "serializer": true,
      "arguments": [
        {
          "comment": "op",
          "fqname": "irn_op",
          "init": null,
          "name": "irn_op",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "serializer": false,
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": "variable",
      "input_name": "cfgpred",
      "attrs": [
        {
          "comment": "entity representing this block",
          "fqname": "entity",
          "init": "NULL",
          "name": "entity",
          "to_flags": null,
          "type": "ir_entity*",
          "noprop": false
        }
      ],
      "arguments": [
        {
          "comment": "size of additional inputs array",
          "fqname": "arity",
          "init": null,
          "name": "arity",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "additional inputs",
          "fqname": "in",
          "init": null,
          "name": "in",
          "to_flags": null,
          "type": "ir_node *const *",
          "noprop": false
        }
      ],
      "attrs_name": "block",
      "name": "Block",
      "doc": "A basic block",
      "attr_struct": "block_attr",
      "pinned": "yes",
      "init": "\n    res->attr.block.backedge = new_backedge_arr(get_irg_obstack(irg), arity);\n    set_Block_matured(res, 1);\n\n    /* Create and initialize array for Phi-node construction. */\n    if (irg_is_constrained(irg, IR_GRAPH_CONSTRAINT_CONSTRUCTION)) {\n        res->attr.block.graph_arr = NEW_ARR_DZ(ir_node*, get_irg_obstack(irg), irg->n_loc);\n    }\n    ",
      "flags": [],
      "mode": "mode_BB",
      "__doc__": "A basic block",
      "block": "NULL",
      "usesGraph": true
    },
    {
      "__module__": "__main__",
      "initattrs": [
        {
          "comment": "",
          "fqname": "exc.pinned",
          "init": "op_pin_state_pinned",
          "name": "pinned",
          "to_flags": null,
          "type": "int",
          "noprop": false
        }
      ],
      "__is_firm_op": true,
      "ins": [{ "comment": "memory dependency", "name": "mem" }],
      "arity": "variable",
      "input_name": "param",
      "attrs": [
        {
          "comment": "kind of builtin",
          "fqname": "kind",
          "init": null,
          "name": "kind",
          "to_flags": null,
          "type": "ir_builtin_kind",
          "noprop": false
        },
        {
          "comment": "method type for the builtin call",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        }
      ],
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "size of additional inputs array",
          "fqname": "arity",
          "init": null,
          "name": "arity",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "additional inputs",
          "fqname": "in",
          "init": null,
          "name": "in",
          "to_flags": null,
          "type": "ir_node *const *",
          "noprop": false
        },
        {
          "comment": "kind of builtin",
          "fqname": "kind",
          "init": null,
          "name": "kind",
          "to_flags": null,
          "type": "ir_builtin_kind",
          "noprop": false
        },
        {
          "comment": "method type for the builtin call",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        }
      ],
      "pinned_init": "op_pin_state_pinned",
      "pinned": "exception",
      "outs": [{ "comment": "memory result", "name": "M" }],
      "name": "Builtin",
      "doc": "performs a backend-specific builtin.",
      "attr_struct": "builtin_attr",
      "attrs_name": "builtin",
      "init": "\n    assert((get_unknown_type() == type) || is_Method_type(type));\n    ",
      "flags": ["uses_memory"],
      "mode": "mode_T",
      "__doc__": "performs a backend-specific builtin.",
      "serializer": true,
      "usesGraph": false
    },
    {
      "__module__": "__main__",
      "initattrs": [
        {
          "comment": "",
          "fqname": "exc.pinned",
          "init": "op_pin_state_pinned",
          "name": "pinned",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "",
          "fqname": "exc.throws_exception",
          "init": "false",
          "name": "throws_exception",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        }
      ],
      "throws_init": "false",
      "__is_firm_op": true,
      "ins": [
        { "comment": "memory dependency", "name": "mem" },
        { "comment": "pointer to called code", "name": "ptr" }
      ],
      "arity": "variable",
      "input_name": "param",
      "attrs": [
        {
          "comment": "type of the call (usually type of the called procedure)",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "pinned_init": "op_pin_state_pinned",
      "attrs_name": "call",
      "outs": [
        { "comment": "memory result", "name": "M" },
        { "comment": "tuple containing all results", "name": "T_result" },
        {
          "comment": "control flow when no exception occurs",
          "name": "X_regular"
        },
        { "comment": "control flow when exception occurred", "name": "X_except" }
      ],
      "name": "Call",
      "doc": "Calls other code. Control flow is transferred to ptr, additional\noperands are passed to the called code. Called code usually performs a\nreturn operation. The operands of this return operation are the result\nof the Call node.",
      "attr_struct": "call_attr",
      "pinned": "exception",
      "init": "\n    assert((get_unknown_type() == type) || is_Method_type(type));\n    ",
      "flags": ["fragile", "uses_memory"],
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "ptr",
          "fqname": "irn_ptr",
          "init": null,
          "name": "irn_ptr",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "size of additional inputs array",
          "fqname": "arity",
          "init": null,
          "name": "arity",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "additional inputs",
          "fqname": "in",
          "init": null,
          "name": "in",
          "to_flags": null,
          "type": "ir_node *const *",
          "noprop": false
        },
        {
          "comment": "type of the call (usually type of the called procedure)",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        }
      ],
      "__doc__": "Calls other code. Control flow is transferred to ptr, additional\n    operands are passed to the called code. Called code usually performs a\n    return operation. The operands of this return operation are the result\n    of the Call node.",
      "serializer": true,
      "mode": "mode_T"
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "arity": 2,
      "attrs": [
        {
          "comment": "Comparison relation",
          "fqname": "relation",
          "init": null,
          "name": "relation",
          "to_flags": null,
          "type": "ir_relation",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "name": "Cmp",
      "doc": "Compares its two operands and checks whether a specified\nrelation (like less or equal) is fulfilled.",
      "attr_struct": "cmp_attr",
      "attrs_name": "cmp",
      "flags": [],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "Comparison relation",
          "fqname": "relation",
          "init": null,
          "name": "relation",
          "to_flags": null,
          "type": "ir_relation",
          "noprop": false
        }
      ],
      "__doc__": "Compares its two operands and checks whether a specified\n       relation (like less or equal) is fulfilled.",
      "serializer": true,
      "mode": "mode_b"
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "condition parameter", "name": "selector" }],
      "arity": 1,
      "attrs": [
        {
          "comment": "can indicate the most likely jump",
          "fqname": "jmp_pred",
          "init": "COND_JMP_PRED_NONE",
          "name": "jmp_pred",
          "to_flags": null,
          "type": "cond_jmp_predicate",
          "noprop": false
        }
      ],
      "pinned": "yes",
      "outs": [
        { "comment": "control flow if operand is \"false\"", "name": "false" },
        { "comment": "control flow if operand is \"true\"", "name": "true" }
      ],
      "name": "Cond",
      "doc": "Conditionally change control flow.",
      "attr_struct": "cond_attr",
      "attrs_name": "cond",
      "flags": ["cfopcode", "forking"],
      "usesGraph": false,
      "mode": "mode_T",
      "__doc__": "Conditionally change control flow.",
      "serializer": true,
      "arguments": [
        {
          "comment": "selector",
          "fqname": "irn_selector",
          "init": null,
          "name": "irn_selector",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "value to express a constraint for", "name": "value" },
        { "comment": "value to compare against", "name": "bound" }
      ],
      "arity": 2,
      "attrs": [
        {
          "comment": "relation of value to bound",
          "fqname": "relation",
          "init": null,
          "name": "relation",
          "to_flags": null,
          "type": "ir_relation",
          "noprop": false
        }
      ],
      "arguments": [
        {
          "comment": "value",
          "fqname": "irn_value",
          "init": null,
          "name": "irn_value",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "bound",
          "fqname": "irn_bound",
          "init": null,
          "name": "irn_bound",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "relation of value to bound",
          "fqname": "relation",
          "init": null,
          "name": "relation",
          "to_flags": null,
          "type": "ir_relation",
          "noprop": false
        }
      ],
      "pinned": "yes",
      "name": "Confirm",
      "doc": "Specifies constraints for a value. This allows explicit representation\nof path-sensitive properties. (Example: This value is always >= 0 on 1\nif-branch then all users within that branch are rerouted to a confirm-node\nspecifying this property).\n\nA constraint is specified for the relation between value and bound.\nvalue is always returned.\nNote that this node does NOT check or assert the constraint, it merely\nspecifies it.",
      "attr_struct": "confirm_attr",
      "attrs_name": "confirm",
      "flags": [],
      "mode": "get_irn_mode(irn_value)",
      "__doc__": "Specifies constraints for a value. This allows explicit representation\n    of path-sensitive properties. (Example: This value is always >= 0 on 1\n    if-branch then all users within that branch are rerouted to a confirm-node\n    specifying this property).\n\n    A constraint is specified for the relation between value and bound.\n    value is always returned.\n    Note that this node does NOT check or assert the constraint, it merely\n    specifies it.",
      "serializer": true,
      "usesGraph": false
    },
    {
      "__module__": "__main__",
      "serializer": true,
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": 0,
      "attrs": [
        {
          "comment": "constant value (a tarval object)",
          "fqname": "tarval",
          "init": null,
          "name": "tarval",
          "to_flags": null,
          "type": "ir_tarval*",
          "noprop": false
        }
      ],
      "usesGraph": true,
      "name": "Const",
      "doc": "Returns a constant value.",
      "attr_struct": "const_attr",
      "attrs_name": "con",
      "flags": ["constlike", "start_block"],
      "arguments": [
        {
          "comment": "constant value (a tarval object)",
          "fqname": "tarval",
          "init": null,
          "name": "tarval",
          "to_flags": null,
          "type": "ir_tarval*",
          "noprop": false
        }
      ],
      "__doc__": "Returns a constant value.",
      "block": "get_irg_start_block(irg)",
      "mode": "get_tarval_mode(tarval)"
    },
    {
      "__module__": "__main__",
      "name": "Conv",
      "doc": "Converts values between modes",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "operand", "name": "op" }],
      "attrs_name": "conv",
      "arity": 1,
      "flags": [],
      "usesGraph": false,
      "__doc__": "Converts values between modes",
      "serializer": true,
      "arguments": [
        {
          "comment": "op",
          "fqname": "irn_op",
          "init": null,
          "name": "irn_op",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "memory dependency", "name": "mem" },
        { "comment": "destination address", "name": "dst" },
        { "comment": "source address", "name": "src" }
      ],
      "constructor_args": [
        {
          "comment": "specifies volatility",
          "fqname": "flags",
          "init": null,
          "name": "flags",
          "to_flags": null,
          "type": "ir_cons_flags",
          "noprop": false
        }
      ],
      "arity": 3,
      "attrs": [
        {
          "comment": "type of copied data",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        },
        {
          "comment": "volatile CopyB nodes have a visible side-effect and may not be optimized",
          "fqname": "volatility",
          "init": "flags & cons_volatile ? volatility_is_volatile : volatility_non_volatile",
          "name": "volatility",
          "to_flags": "%s == volatility_is_volatile ? cons_volatile : cons_none",
          "type": "ir_volatility",
          "noprop": false
        }
      ],
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "dst",
          "fqname": "irn_dst",
          "init": null,
          "name": "irn_dst",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "src",
          "fqname": "irn_src",
          "init": null,
          "name": "irn_src",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "type of copied data",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        },
        {
          "comment": "specifies volatility",
          "fqname": "flags",
          "init": null,
          "name": "flags",
          "to_flags": null,
          "type": "ir_cons_flags",
          "noprop": false
        }
      ],
      "name": "CopyB",
      "doc": "Copies a block of memory with statically known size/type.",
      "attr_struct": "copyb_attr",
      "attrs_name": "copyb",
      "flags": ["uses_memory"],
      "mode": "mode_M",
      "__doc__": "Copies a block of memory with statically known size/type.",
      "serializer": true,
      "usesGraph": false
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": 0,
      "usesGraph": false,
      "pinned": "yes",
      "name": "Deleted",
      "doc": "Internal node which is temporary set to nodes which are already removed\nfrom the graph.",
      "attrs_name": "deleted",
      "flags": [],
      "arguments": [],
      "constructor": false,
      "__doc__": "Internal node which is temporary set to nodes which are already removed\n    from the graph.",
      "serializer": false,
      "mode": "mode_Bad"
    },
    {
      "__module__": "__main__",
      "initattrs": [
        {
          "comment": "",
          "fqname": "exc.pinned",
          "init": "pinned",
          "name": "pin_state",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "",
          "fqname": "exc.throws_exception",
          "init": "false",
          "name": "throws_exception",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        }
      ],
      "op_index": 1,
      "throws_init": "false",
      "__is_firm_op": true,
      "ins": [
        { "comment": "memory dependency", "name": "mem" },
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "arity": 3,
      "arity_override": "oparity_binary",
      "attrs": [
        {
          "comment": "mode of the result value",
          "fqname": "resmode",
          "init": "get_irn_mode(irn_left)",
          "name": "resmode",
          "to_flags": null,
          "type": "ir_mode*",
          "noprop": false
        },
        {
          "comment": "Set when division remainder is known to be zero",
          "fqname": "no_remainder",
          "init": "0",
          "name": "no_remainder",
          "to_flags": null,
          "type": "int",
          "noprop": false
        }
      ],
      "pinned": "exception",
      "outs": [
        { "comment": "memory result", "name": "M" },
        { "comment": "result of computation", "name": "res" },
        {
          "comment": "control flow when no exception occurs",
          "name": "X_regular"
        },
        { "comment": "control flow when exception occurred", "name": "X_except" }
      ],
      "name": "Div",
      "doc": "returns the quotient of its 2 operands",
      "attr_struct": "div_attr",
      "attrs_name": "div",
      "flags": ["fragile", "uses_memory", "const_memory"],
      "usesGraph": false,
      "mode": "mode_T",
      "__doc__": "returns the quotient of its 2 operands",
      "serializer": true,
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "pinned state",
          "fqname": "pinned",
          "init": null,
          "name": "pinned",
          "to_flags": null,
          "type": "int",
          "noprop": false
        }
      ]
    },
    {
      "pinned": "yes",
      "__module__": "__main__",
      "name": "Dummy",
      "doc": "A placeholder value. This is used when constructing cyclic graphs where\nyou have cases where not all predecessors of a phi-node are known. Dummy\nnodes are used for the unknown predecessors and replaced later.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "attrs_name": "dummy",
      "arity": 0,
      "flags": ["cfopcode", "start_block", "constlike", "dump_noblock"],
      "arguments": [
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        }
      ],
      "usesGraph": true,
      "__doc__": "A placeholder value. This is used when constructing cyclic graphs where\n    you have cases where not all predecessors of a phi-node are known. Dummy\n    nodes are used for the unknown predecessors and replaced later.",
      "block": "get_irg_start_block(irg)",
      "serializer": true
    },
    {
      "__module__": "__main__",
      "serializer": true,
      "initattrs": [],
      "singleton": true,
      "__is_firm_op": true,
      "arity": "dynamic",
      "input_name": "keepalive",
      "arguments": [
        {
          "comment": "size of additional inputs array",
          "fqname": "arity",
          "init": null,
          "name": "arity",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "additional inputs",
          "fqname": "in",
          "init": null,
          "name": "in",
          "to_flags": null,
          "type": "ir_node *const *",
          "noprop": false
        }
      ],
      "ins": [],
      "pinned": "yes",
      "name": "End",
      "doc": "Last node of a graph. It references nodes in endless loops (so called\nkeepalive edges)",
      "attrs_name": "end",
      "flags": ["cfopcode"],
      "mode": "mode_X",
      "__doc__": "Last node of a graph. It references nodes in endless loops (so called\n    keepalive edges)",
      "block": "get_irg_end_block(irg)",
      "usesGraph": true
    },
    {
      "__module__": "__main__",
      "name": "Eor",
      "doc": "returns the result of a bitwise exclusive or operation of its operands.\n\nThis is also known as the Xor operation.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "eor",
      "arity": 2,
      "flags": ["commutative"],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the result of a bitwise exclusive or operation of its operands.\n\n    This is also known as the Xor operation.",
      "serializer": true,
      "mode": "get_irn_mode(irn_left)"
    },
    {
      "pinned": "yes",
      "__module__": "__main__",
      "name": "Free",
      "doc": "Frees a block of memory previously allocated by an Alloc node",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "memory dependency", "name": "mem" },
        { "comment": "pointer to the object to free", "name": "ptr" }
      ],
      "attrs_name": "free",
      "arity": 2,
      "flags": ["uses_memory", "const_memory"],
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "ptr",
          "fqname": "irn_ptr",
          "init": null,
          "name": "irn_ptr",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "Frees a block of memory previously allocated by an Alloc node",
      "serializer": true,
      "mode": "mode_M"
    },
    {
      "pinned": "yes",
      "__module__": "__main__",
      "name": "IJmp",
      "doc": "Jumps to the code in its argument. The code has to be in the same\nfunction and the destination must be one of the blocks reachable\nby the tuple results",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "target address of the jump", "name": "target" }],
      "attrs_name": "ijmp",
      "arity": 1,
      "flags": ["cfopcode", "forking", "keep", "unknown_jump"],
      "arguments": [
        {
          "comment": "target",
          "fqname": "irn_target",
          "init": null,
          "name": "irn_target",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "Jumps to the code in its argument. The code has to be in the same\n    function and the destination must be one of the blocks reachable\n    by the tuple results",
      "serializer": true,
      "mode": "mode_X"
    },
    {
      "__module__": "__main__",
      "name": "Id",
      "doc": "Returns its operand unchanged.\n\nThis is mainly used when exchanging nodes. Usually you shouldn't see Id\nnodes since the getters/setters for node inputs skip them automatically.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "the value which is returned unchanged", "name": "pred" }
      ],
      "attrs_name": "id",
      "arity": 1,
      "flags": [],
      "usesGraph": false,
      "constructor": false,
      "__doc__": "Returns its operand unchanged.\n\n    This is mainly used when exchanging nodes. Usually you shouldn't see Id\n    nodes since the getters/setters for node inputs skip them automatically.",
      "serializer": false,
      "arguments": [
        {
          "comment": "pred",
          "fqname": "irn_pred",
          "init": null,
          "name": "irn_pred",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        }
      ]
    },
    {
      "pinned": "yes",
      "__module__": "__main__",
      "name": "Jmp",
      "doc": "Jumps to the block connected through the out-value",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "attrs_name": "jmp",
      "arity": 0,
      "flags": ["cfopcode"],
      "arguments": [],
      "usesGraph": false,
      "__doc__": "Jumps to the block connected through the out-value",
      "serializer": true,
      "mode": "mode_X"
    },
    {
      "__module__": "__main__",
      "initattrs": [
        {
          "comment": "",
          "fqname": "exc.pinned",
          "init": "flags & cons_floats ? op_pin_state_floats : op_pin_state_pinned",
          "name": "pinned",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "",
          "fqname": "exc.throws_exception",
          "init": "(flags & cons_throws_exception) != 0",
          "name": "throws_exception",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        }
      ],
      "throws_init": "(flags & cons_throws_exception) != 0",
      "__is_firm_op": true,
      "ins": [
        { "comment": "memory dependency", "name": "mem" },
        { "comment": "address to load from", "name": "ptr" }
      ],
      "constructor_args": [
        {
          "comment": "specifies alignment, volatility and pin state",
          "fqname": "flags",
          "init": null,
          "name": "flags",
          "to_flags": null,
          "type": "ir_cons_flags",
          "noprop": false
        }
      ],
      "arity": 2,
      "attrs": [
        {
          "comment": "mode of the value to be loaded",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode*",
          "noprop": false
        },
        {
          "comment": "The type of the object which is stored at ptr (need not match with mode)",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        },
        {
          "comment": "volatile loads are a visible side-effect and may not be optimized",
          "fqname": "volatility",
          "init": "flags & cons_volatile ? volatility_is_volatile : volatility_non_volatile",
          "name": "volatility",
          "to_flags": "%s == volatility_is_volatile ? cons_volatile : cons_none",
          "type": "ir_volatility",
          "noprop": false
        },
        {
          "comment": "pointers to unaligned loads don't need to respect the load-mode/type alignments",
          "fqname": "unaligned",
          "init": "flags & cons_unaligned ? align_non_aligned : align_is_aligned",
          "name": "unaligned",
          "to_flags": "%s == align_non_aligned ? cons_unaligned : cons_none",
          "type": "ir_align",
          "noprop": false
        }
      ],
      "pinned_init": "flags & cons_floats ? op_pin_state_floats : op_pin_state_pinned",
      "attrs_name": "load",
      "outs": [
        { "comment": "memory result", "name": "M" },
        { "comment": "result of load operation", "name": "res" },
        {
          "comment": "control flow when no exception occurs",
          "name": "X_regular"
        },
        { "comment": "control flow when exception occurred", "name": "X_except" }
      ],
      "name": "Load",
      "doc": "Loads a value from memory (heap or stack).",
      "attr_struct": "load_attr",
      "pinned": "exception",
      "flags": ["fragile", "uses_memory", "const_memory"],
      "usesGraph": false,
      "mode": "mode_T",
      "__doc__": "Loads a value from memory (heap or stack).",
      "serializer": true,
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "ptr",
          "fqname": "irn_ptr",
          "init": null,
          "name": "irn_ptr",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "mode of the value to be loaded",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode*",
          "noprop": false
        },
        {
          "comment": "The type of the object which is stored at ptr (need not match with mode)",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        },
        {
          "comment": "specifies alignment, volatility and pin state",
          "fqname": "flags",
          "init": null,
          "name": "flags",
          "to_flags": null,
          "type": "ir_cons_flags",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "pointer to object to select from", "name": "ptr" }],
      "arity": 1,
      "attrs": [
        {
          "comment": "entity which is selected",
          "fqname": "entity",
          "init": null,
          "name": "entity",
          "to_flags": null,
          "type": "ir_entity*",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "name": "Member",
      "doc": "Computes the address of a compound type member given the base address\nof an instance of the compound type.\n\nA Member node must only produce a NULL pointer if the ptr input is NULL.",
      "attr_struct": "member_attr",
      "attrs_name": "member",
      "flags": [],
      "arguments": [
        {
          "comment": "ptr",
          "fqname": "irn_ptr",
          "init": null,
          "name": "irn_ptr",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "entity which is selected",
          "fqname": "entity",
          "init": null,
          "name": "entity",
          "to_flags": null,
          "type": "ir_entity*",
          "noprop": false
        }
      ],
      "__doc__": "Computes the address of a compound type member given the base address\n    of an instance of the compound type.\n\n    A Member node must only produce a NULL pointer if the ptr input is NULL.",
      "serializer": true,
      "mode": "mode_P"
    },
    {
      "__module__": "__main__",
      "name": "Minus",
      "doc": "returns the additive inverse of its operand",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "operand", "name": "op" }],
      "attrs_name": "minus",
      "arity": 1,
      "flags": [],
      "arguments": [
        {
          "comment": "op",
          "fqname": "irn_op",
          "init": null,
          "name": "irn_op",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the additive inverse of its operand",
      "serializer": true,
      "mode": "get_irn_mode(irn_op)"
    },
    {
      "__module__": "__main__",
      "initattrs": [
        {
          "comment": "",
          "fqname": "exc.pinned",
          "init": "pinned",
          "name": "pin_state",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "",
          "fqname": "exc.throws_exception",
          "init": "false",
          "name": "throws_exception",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        }
      ],
      "op_index": 1,
      "throws_init": "false",
      "__is_firm_op": true,
      "ins": [
        { "comment": "memory dependency", "name": "mem" },
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "arity": 3,
      "arity_override": "oparity_binary",
      "attrs": [
        {
          "comment": "mode of the result",
          "fqname": "resmode",
          "init": "get_irn_mode(irn_left)",
          "name": "resmode",
          "to_flags": null,
          "type": "ir_mode*",
          "noprop": false
        }
      ],
      "pinned": "exception",
      "outs": [
        { "comment": "memory result", "name": "M" },
        { "comment": "result of computation", "name": "res" },
        {
          "comment": "control flow when no exception occurs",
          "name": "X_regular"
        },
        { "comment": "control flow when exception occurred", "name": "X_except" }
      ],
      "name": "Mod",
      "doc": "returns the remainder of its operands from an implied division.\n\nExamples:\n\n* mod(5,3)   produces 2\n* mod(5,-3)  produces 2\n* mod(-5,3)  produces -2\n* mod(-5,-3) produces -2",
      "attr_struct": "mod_attr",
      "attrs_name": "mod",
      "flags": ["fragile", "uses_memory", "const_memory"],
      "usesGraph": false,
      "mode": "mode_T",
      "__doc__": "returns the remainder of its operands from an implied division.\n\n    Examples:\n\n    * mod(5,3)   produces 2\n    * mod(5,-3)  produces 2\n    * mod(-5,3)  produces -2\n    * mod(-5,-3) produces -2\n    ",
      "serializer": true,
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "pinned state",
          "fqname": "pinned",
          "init": null,
          "name": "pinned",
          "to_flags": null,
          "type": "int",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "name": "Mul",
      "doc": "returns the product of its operands",
      "initattrs": [],
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "mul",
      "arity": 2,
      "flags": ["commutative"],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the product of its operands",
      "serializer": true,
      "mode": "get_irn_mode(irn_left)"
    },
    {
      "__module__": "__main__",
      "name": "Mulh",
      "doc": "returns the upper word of the product of its operands (the part which\nwould not fit into the result mode of a normal Mul anymore)",
      "initattrs": [],
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "mulh",
      "arity": 2,
      "flags": ["commutative"],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the upper word of the product of its operands (the part which\n    would not fit into the result mode of a normal Mul anymore)",
      "serializer": true,
      "mode": "get_irn_mode(irn_left)"
    },
    {
      "__module__": "__main__",
      "name": "Mux",
      "doc": "returns the false or true operand depending on the value of the sel\noperand",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "value making the output selection", "name": "sel" },
        { "comment": "selected if sel input is false", "name": "false" },
        { "comment": "selected if sel input is true", "name": "true" }
      ],
      "attrs_name": "mux",
      "arity": 3,
      "flags": [],
      "arguments": [
        {
          "comment": "sel",
          "fqname": "irn_sel",
          "init": null,
          "name": "irn_sel",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "false",
          "fqname": "irn_false",
          "init": null,
          "name": "irn_false",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "true",
          "fqname": "irn_true",
          "init": null,
          "name": "irn_true",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the false or true operand depending on the value of the sel\n    operand",
      "serializer": true,
      "mode": "get_irn_mode(irn_false)"
    },
    {
      "singleton": true,
      "serializer": true,
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": 0,
      "usesGraph": true,
      "pinned": "yes",
      "name": "NoMem",
      "__module__": "__main__",
      "doc": "Placeholder node for cases where you don't need any memory input",
      "attrs_name": "nomem",
      "flags": ["dump_noblock", "start_block"],
      "arguments": [],
      "__doc__": "Placeholder node for cases where you don't need any memory input",
      "block": "get_irg_start_block(irg)",
      "mode": "mode_M"
    },
    {
      "__module__": "__main__",
      "name": "Not",
      "doc": "returns the bitwise complement of a value. Works for boolean values, too.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "operand", "name": "op" }],
      "attrs_name": "not",
      "arity": 1,
      "flags": [],
      "arguments": [
        {
          "comment": "op",
          "fqname": "irn_op",
          "init": null,
          "name": "irn_op",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the bitwise complement of a value. Works for boolean values, too.",
      "serializer": true,
      "mode": "get_irn_mode(irn_op)"
    },
    {
      "__module__": "__main__",
      "name": "Offset",
      "doc": "Symbolic constant that represents the offset of an entity in its owner type.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": 0,
      "arguments": [
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        },
        {
          "comment": "entity to operate on",
          "fqname": "entity",
          "init": null,
          "name": "entity",
          "to_flags": null,
          "type": "ir_entity*",
          "noprop": false
        }
      ],
      "usesGraph": true,
      "__doc__": "Symbolic constant that represents the offset of an entity in its owner type.",
      "block": "get_irg_start_block(irg)",
      "serializer": true
    },
    {
      "__module__": "__main__",
      "name": "Or",
      "doc": "returns the result of a bitwise or operation of its operands",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "or",
      "arity": 2,
      "flags": ["commutative"],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the result of a bitwise or operation of its operands",
      "serializer": true,
      "mode": "get_irn_mode(irn_left)"
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": "variable",
      "input_name": "pred",
      "attrs": [
        {
          "comment": "whether Phi represents the observable effect of a (possibly) nonterminating loop",
          "fqname": "loop",
          "init": "0",
          "name": "loop",
          "to_flags": null,
          "type": "int",
          "noprop": false
        }
      ],
      "pinned": "yes",
      "name": "Phi",
      "doc": "Choose a value based on control flow. A phi node has 1 input for each\npredecessor of its block. If a block is entered from its nth predecessor\nall phi nodes produce their nth input as result.",
      "attr_struct": "phi_attr",
      "attrs_name": "phi",
      "init": "\n    res->attr.phi.u.backedge = new_backedge_arr(get_irg_obstack(irg), arity);",
      "flags": [],
      "arguments": [
        {
          "comment": "size of additional inputs array",
          "fqname": "arity",
          "init": null,
          "name": "arity",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "additional inputs",
          "fqname": "in",
          "init": null,
          "name": "in",
          "to_flags": null,
          "type": "ir_node *const *",
          "noprop": false
        },
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        }
      ],
      "__doc__": "Choose a value based on control flow. A phi node has 1 input for each\n    predecessor of its block. If a block is entered from its nth predecessor\n    all phi nodes produce their nth input as result.",
      "serializer": false,
      "usesGraph": false
    },
    {
      "pinned": "yes",
      "__module__": "__main__",
      "name": "Pin",
      "doc": "Pin the value of the node node in the current block. No users of the Pin\nnode can float above the Block of the Pin. The node cannot float behind\nthis block. Often used to Pin the NoMem node.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "value which is pinned", "name": "op" }],
      "attrs_name": "pin",
      "arity": 1,
      "flags": [],
      "arguments": [
        {
          "comment": "op",
          "fqname": "irn_op",
          "init": null,
          "name": "irn_op",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "Pin the value of the node node in the current block. No users of the Pin\n    node can float above the Block of the Pin. The node cannot float behind\n    this block. Often used to Pin the NoMem node.",
      "serializer": true,
      "mode": "get_irn_mode(irn_op)"
    },
    {
      "block": "get_nodes_block(irn_pred)",
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        {
          "comment": "the tuple value from which a part is extracted",
          "name": "pred"
        }
      ],
      "arity": 1,
      "attrs": [
        {
          "comment": "number of tuple component to be extracted",
          "fqname": "num",
          "init": null,
          "name": "num",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        }
      ],
      "name": "Proj",
      "doc": "returns an entry of a tuple value",
      "attr_struct": "proj_attr",
      "attrs_name": "proj",
      "flags": [],
      "arguments": [
        {
          "comment": "pred",
          "fqname": "irn_pred",
          "init": null,
          "name": "irn_pred",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        },
        {
          "comment": "number of tuple component to be extracted",
          "fqname": "num",
          "init": null,
          "name": "num",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        }
      ],
      "__doc__": "returns an entry of a tuple value",
      "serializer": true,
      "usesGraph": false
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "memory dependency", "name": "mem" },
        {
          "comment": "pointer to exception object to be thrown",
          "name": "exo_ptr"
        }
      ],
      "arity": 2,
      "usesGraph": false,
      "pinned": "yes",
      "outs": [
        { "comment": "memory result", "name": "M" },
        { "comment": "control flow to exception handler", "name": "X" }
      ],
      "name": "Raise",
      "doc": "Raises an exception. Unconditional change of control flow. Writes an\nexplicit Except variable to memory to pass it to the exception handler.\nMust be lowered to a Call to a runtime check function.",
      "attrs_name": "raise",
      "flags": ["cfopcode"],
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "exo_ptr",
          "fqname": "irn_exo_ptr",
          "init": null,
          "name": "irn_exo_ptr",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "__doc__": "Raises an exception. Unconditional change of control flow. Writes an\n    explicit Except variable to memory to pass it to the exception handler.\n    Must be lowered to a Call to a runtime check function.",
      "serializer": true,
      "mode": "mode_T"
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "memory dependency", "name": "mem" }],
      "arity": "variable",
      "input_name": "res",
      "usesGraph": false,
      "pinned": "yes",
      "name": "Return",
      "doc": "Returns from the current function. Takes memory and return values as\noperands.",
      "attrs_name": "return",
      "flags": ["cfopcode"],
      "mode": "mode_X",
      "__doc__": "Returns from the current function. Takes memory and return values as\n    operands.",
      "serializer": true,
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "size of additional inputs array",
          "fqname": "arity",
          "init": null,
          "name": "arity",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "additional inputs",
          "fqname": "in",
          "init": null,
          "name": "in",
          "to_flags": null,
          "type": "ir_node *const *",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "pointer to array to select from", "name": "ptr" },
        { "comment": "index to select", "name": "index" }
      ],
      "arity": 2,
      "attrs": [
        {
          "comment": "array type",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "name": "Sel",
      "doc": "Computes the address of an array element from the array base pointer and\nan index.\n\nA Sel node must only produce a NULL pointer if the ptr input is NULL.",
      "attr_struct": "sel_attr",
      "attrs_name": "sel",
      "flags": [],
      "arguments": [
        {
          "comment": "ptr",
          "fqname": "irn_ptr",
          "init": null,
          "name": "irn_ptr",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "index",
          "fqname": "irn_index",
          "init": null,
          "name": "irn_index",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "array type",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        }
      ],
      "__doc__": "Computes the address of an array element from the array base pointer and\n    an index.\n\n    A Sel node must only produce a NULL pointer if the ptr input is NULL.",
      "serializer": true,
      "mode": "mode_P"
    },
    {
      "__module__": "__main__",
      "name": "Shl",
      "doc": "Returns its first operands bits shifted left by the amount of the 2nd\noperand.\nThe right input (shift amount) must be an unsigned integer value.\nIf the result mode has modulo_shift!=0, then the effective shift amount is\nthe right input modulo this modulo_shift amount.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "shl",
      "arity": 2,
      "flags": [],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "Returns its first operands bits shifted left by the amount of the 2nd\n    operand.\n    The right input (shift amount) must be an unsigned integer value.\n    If the result mode has modulo_shift!=0, then the effective shift amount is\n    the right input modulo this modulo_shift amount.",
      "serializer": true,
      "mode": "get_irn_mode(irn_left)"
    },
    {
      "__module__": "__main__",
      "name": "Shr",
      "doc": "Returns its first operands bits shifted right by the amount of the 2nd\noperand. No special handling for the sign bit is performed (zero extension).\nThe right input (shift amount) must be an unsigned integer value.\nIf the result mode has modulo_shift!=0, then the effective shift amount is\nthe right input modulo this modulo_shift amount.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "shr",
      "arity": 2,
      "flags": [],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "Returns its first operands bits shifted right by the amount of the 2nd\n    operand. No special handling for the sign bit is performed (zero extension).\n    The right input (shift amount) must be an unsigned integer value.\n    If the result mode has modulo_shift!=0, then the effective shift amount is\n    the right input modulo this modulo_shift amount.",
      "serializer": true,
      "mode": "get_irn_mode(irn_left)"
    },
    {
      "__module__": "__main__",
      "name": "Shrs",
      "doc": "Returns its first operands bits shifted right by the amount of the 2nd\noperand. The leftmost bit (usually the sign bit) stays the same\n(sign extension).\nThe right input (shift amount) must be an unsigned integer value.\nIf the result mode has modulo_shift!=0, then the effective shift amount is\nthe right input modulo this modulo_shift amount.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "shrs",
      "arity": 2,
      "flags": [],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "Returns its first operands bits shifted right by the amount of the 2nd\n    operand. The leftmost bit (usually the sign bit) stays the same\n    (sign extension).\n    The right input (shift amount) must be an unsigned integer value.\n    If the result mode has modulo_shift!=0, then the effective shift amount is\n    the right input modulo this modulo_shift amount.",
      "serializer": true,
      "mode": "get_irn_mode(irn_left)"
    },
    {
      "__module__": "__main__",
      "name": "Size",
      "doc": "A symbolic constant that represents the size of a type",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": 0,
      "arguments": [
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        },
        {
          "comment": "type to operate on",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        }
      ],
      "usesGraph": true,
      "__doc__": "A symbolic constant that represents the size of a type",
      "block": "get_irg_start_block(irg)",
      "serializer": true
    },
    {
      "__module__": "__main__",
      "serializer": true,
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "arity": 0,
      "usesGraph": true,
      "singleton": true,
      "pinned": "yes",
      "outs": [
        { "comment": "initial memory", "name": "M" },
        { "comment": "frame base pointer", "name": "P_frame_base" },
        { "comment": "function arguments", "name": "T_args" }
      ],
      "name": "Start",
      "doc": "The first node of a graph. Execution starts with this node.",
      "attrs_name": "start",
      "flags": ["start_block"],
      "arguments": [],
      "__doc__": "The first node of a graph. Execution starts with this node.",
      "block": "get_irg_start_block(irg)",
      "mode": "mode_T"
    },
    {
      "__module__": "__main__",
      "initattrs": [
        {
          "comment": "",
          "fqname": "exc.pinned",
          "init": "flags & cons_floats ? op_pin_state_floats : op_pin_state_pinned",
          "name": "pinned",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "",
          "fqname": "exc.throws_exception",
          "init": "(flags & cons_throws_exception) != 0",
          "name": "throws_exception",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        }
      ],
      "throws_init": "(flags & cons_throws_exception) != 0",
      "__is_firm_op": true,
      "ins": [
        { "comment": "memory dependency", "name": "mem" },
        { "comment": "address to store to", "name": "ptr" },
        { "comment": "value to store", "name": "value" }
      ],
      "constructor_args": [
        {
          "comment": "specifies alignment, volatility and pin state",
          "fqname": "flags",
          "init": null,
          "name": "flags",
          "to_flags": null,
          "type": "ir_cons_flags",
          "noprop": false
        }
      ],
      "arity": 3,
      "attrs": [
        {
          "comment": "The type of the object which is stored at ptr (need not match with value's type)",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        },
        {
          "comment": "volatile stores are a visible side-effect and may not be optimized",
          "fqname": "volatility",
          "init": "flags & cons_volatile ? volatility_is_volatile : volatility_non_volatile",
          "name": "volatility",
          "to_flags": "%s == volatility_is_volatile ? cons_volatile : cons_none",
          "type": "ir_volatility",
          "noprop": false
        },
        {
          "comment": "pointers to unaligned stores don't need to respect the load-mode/type alignments",
          "fqname": "unaligned",
          "init": "flags & cons_unaligned ? align_non_aligned : align_is_aligned",
          "name": "unaligned",
          "to_flags": "%s == align_non_aligned ? cons_unaligned : cons_none",
          "type": "ir_align",
          "noprop": false
        }
      ],
      "pinned_init": "flags & cons_floats ? op_pin_state_floats : op_pin_state_pinned",
      "attrs_name": "store",
      "outs": [
        { "comment": "memory result", "name": "M" },
        {
          "comment": "control flow when no exception occurs",
          "name": "X_regular"
        },
        { "comment": "control flow when exception occurred", "name": "X_except" }
      ],
      "name": "Store",
      "doc": "Stores a value into memory (heap or stack).",
      "attr_struct": "store_attr",
      "pinned": "exception",
      "flags": ["fragile", "uses_memory"],
      "usesGraph": false,
      "mode": "mode_T",
      "__doc__": "Stores a value into memory (heap or stack).",
      "serializer": true,
      "arguments": [
        {
          "comment": "mem",
          "fqname": "irn_mem",
          "init": null,
          "name": "irn_mem",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "ptr",
          "fqname": "irn_ptr",
          "init": null,
          "name": "irn_ptr",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "value",
          "fqname": "irn_value",
          "init": null,
          "name": "irn_value",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "The type of the object which is stored at ptr (need not match with value's type)",
          "fqname": "type",
          "init": null,
          "name": "type",
          "to_flags": null,
          "type": "ir_type*",
          "noprop": false
        },
        {
          "comment": "specifies alignment, volatility and pin state",
          "fqname": "flags",
          "init": null,
          "name": "flags",
          "to_flags": null,
          "type": "ir_cons_flags",
          "noprop": false
        }
      ]
    },
    {
      "__module__": "__main__",
      "name": "Sub",
      "doc": "returns the difference of its operands",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [
        { "comment": "first operand", "name": "left" },
        { "comment": "second operand", "name": "right" }
      ],
      "attrs_name": "sub",
      "arity": 2,
      "flags": [],
      "arguments": [
        {
          "comment": "left",
          "fqname": "irn_left",
          "init": null,
          "name": "irn_left",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "right",
          "fqname": "irn_right",
          "init": null,
          "name": "irn_right",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "__doc__": "returns the difference of its operands",
      "serializer": true,
      "mode": "mode_is_reference(get_irn_mode(irn_right)) ? get_reference_offset_mode(get_irn_mode(irn_left)) : get_irn_mode(irn_left)"
    },
    {
      "__module__": "__main__",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [{ "comment": "input selector", "name": "selector" }],
      "arity": 1,
      "attrs": [
        {
          "comment": "number of outputs (including pn_Switch_default)",
          "fqname": "n_outs",
          "init": null,
          "name": "n_outs",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        },
        {
          "comment": "table describing mapping from input values to Proj numbers",
          "fqname": "table",
          "init": null,
          "name": "table",
          "to_flags": null,
          "type": "ir_switch_table*",
          "noprop": false
        }
      ],
      "arguments": [
        {
          "comment": "selector",
          "fqname": "irn_selector",
          "init": null,
          "name": "irn_selector",
          "to_flags": null,
          "type": "ir_node *",
          "noprop": false
        },
        {
          "comment": "number of outputs (including pn_Switch_default)",
          "fqname": "n_outs",
          "init": null,
          "name": "n_outs",
          "to_flags": null,
          "type": "unsigned",
          "noprop": false
        },
        {
          "comment": "table describing mapping from input values to Proj numbers",
          "fqname": "table",
          "init": null,
          "name": "table",
          "to_flags": null,
          "type": "ir_switch_table*",
          "noprop": false
        }
      ],
      "attrs_name": "switcha",
      "outs": [
        { "comment": "control flow if no other case matches", "name": "default" }
      ],
      "name": "Switch",
      "doc": "Change control flow. The destination is chosen based on an integer\ninput value which is looked up in a table.\n\nBackends can implement this efficiently using a jump table.",
      "attr_struct": "switch_attr",
      "pinned": "yes",
      "flags": ["cfopcode", "forking"],
      "mode": "mode_T",
      "__doc__": "Change control flow. The destination is chosen based on an integer\n    input value which is looked up in a table.\n\n    Backends can implement this efficiently using a jump table.",
      "serializer": true,
      "usesGraph": false
    },
    {
      "__module__": "__main__",
      "name": "Sync",
      "doc": "The Sync operation unifies several partial memory blocks. These blocks\nhave to be pairwise disjunct or the values in common locations have to\nbe identical.  This operation allows to specify all operations that\neventually need several partial memory blocks as input with a single\nentrance by unifying the memories with a preceding Sync operation.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "attrs_name": "sync",
      "arity": "dynamic",
      "input_name": "pred",
      "arguments": [
        {
          "comment": "size of additional inputs array",
          "fqname": "arity",
          "init": null,
          "name": "arity",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "additional inputs",
          "fqname": "in",
          "init": null,
          "name": "in",
          "to_flags": null,
          "type": "ir_node *const *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "flags": [],
      "__doc__": "The Sync operation unifies several partial memory blocks. These blocks\n    have to be pairwise disjunct or the values in common locations have to\n    be identical.  This operation allows to specify all operations that\n    eventually need several partial memory blocks as input with a single\n    entrance by unifying the memories with a preceding Sync operation.",
      "serializer": true,
      "mode": "mode_M"
    },
    {
      "__module__": "__main__",
      "name": "Tuple",
      "doc": "Builds a Tuple from single values.\n\nThis is needed to implement optimizations that remove a node that produced\na tuple.  The node can be replaced by the Tuple operation so that the\nfollowing Proj nodes have not to be changed. (They are hard to find due to\nthe implementation with pointers in only one direction.) The Tuple node is\nsmaller than any other node, so that a node can be changed into a Tuple by\njust changing its opcode and giving it a new in array.",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "attrs_name": "tuple",
      "arity": "variable",
      "input_name": "pred",
      "arguments": [
        {
          "comment": "size of additional inputs array",
          "fqname": "arity",
          "init": null,
          "name": "arity",
          "to_flags": null,
          "type": "int",
          "noprop": false
        },
        {
          "comment": "additional inputs",
          "fqname": "in",
          "init": null,
          "name": "in",
          "to_flags": null,
          "type": "ir_node *const *",
          "noprop": false
        }
      ],
      "usesGraph": false,
      "flags": [],
      "__doc__": "Builds a Tuple from single values.\n\n    This is needed to implement optimizations that remove a node that produced\n    a tuple.  The node can be replaced by the Tuple operation so that the\n    following Proj nodes have not to be changed. (They are hard to find due to\n    the implementation with pointers in only one direction.) The Tuple node is\n    smaller than any other node, so that a node can be changed into a Tuple by\n    just changing its opcode and giving it a new in array.",
      "serializer": true,
      "mode": "mode_T"
    },
    {
      "pinned": "yes",
      "__module__": "__main__",
      "name": "Unknown",
      "doc": "Returns an unknown (at compile- and runtime) value. It is a valid\noptimization to replace an Unknown by any other constant value.\n\nBe careful when optimising Unknown values, you cannot simply replace\nUnknown+x or Unknown<x with a new Unknown node if there are multiple\nusers of the original unknown node!",
      "initattrs": [],
      "__is_firm_op": true,
      "ins": [],
      "attrs_name": "unknown",
      "arity": 0,
      "flags": ["start_block", "constlike", "dump_noblock"],
      "arguments": [
        {
          "comment": "mode of the operations result",
          "fqname": "mode",
          "init": null,
          "name": "mode",
          "to_flags": null,
          "type": "ir_mode *",
          "noprop": false
        }
      ],
      "usesGraph": true,
      "__doc__": "Returns an unknown (at compile- and runtime) value. It is a valid\n    optimization to replace an Unknown by any other constant value.\n\n    Be careful when optimising Unknown values, you cannot simply replace\n    Unknown+x or Unknown<x with a new Unknown node if there are multiple\n    users of the original unknown node!",
      "block": "get_irg_start_block(irg)",
      "serializer": true
    }
  ]
