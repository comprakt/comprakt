/* automatically generated by rust-bindgen */

pub const cc_bits: u32 = 4278190080;
pub const cc_cdecl_set: u32 = 0;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const DEFAULT_CLONE_THRESHOLD: u32 = 20;
pub type ir_visited_t = ::std::os::raw::c_ulong;
pub type ir_label_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbg_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_dbg_info {
    _unused: [u8; 0],
}
pub type ident = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_op {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_mode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_edge_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_heights_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_tarval {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_graph {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_prog {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_loop {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_entity {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_cdep {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ir_initializer_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_machine_triple_t {
    _unused: [u8; 0],
}
pub type irg_walk_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ir_node, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_switch_table {
    _unused: [u8; 0],
}
pub type uninitialized_local_variable_func_t = ::std::option::Option<
    unsafe extern "C" fn(irg: *mut ir_graph, mode: *mut ir_mode, pos: ::std::os::raw::c_int)
        -> *mut ir_node,
>;
pub mod ir_relation {
    pub type Type = u32;
    pub const False: Type = 0;
    pub const Equal: Type = 1;
    pub const Less: Type = 2;
    pub const Greater: Type = 4;
    pub const Unordered: Type = 8;
    pub const LessEqual: Type = 3;
    pub const GreaterEqual: Type = 5;
    pub const LessGreater: Type = 6;
    pub const LessEqualGreater: Type = 7;
    pub const UnorderedEqual: Type = 9;
    pub const UnorderedLess: Type = 10;
    pub const UnorderedLessEqual: Type = 11;
    pub const UnorderedGreater: Type = 12;
    pub const UnorderedGreaterEqual: Type = 13;
    pub const UnorderedLessGreater: Type = 14;
    pub const True: Type = 15;
}
pub mod ir_cons_flags {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const Volatile: Type = 1;
    pub const Unaligned: Type = 2;
    pub const Floats: Type = 4;
    pub const ThrowsException: Type = 8;
}
pub mod op_pin_state {
    pub type Type = u32;
    pub const Floats: Type = 0;
    pub const Pinned: Type = 1;
    pub const ExcPinned: Type = 2;
}
pub mod cond_jmp_predicate {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const True: Type = 1;
    pub const False: Type = 2;
}
pub mod mtp_additional_properties {
    pub type Type = u32;
    pub const NoProperty: Type = 0;
    pub const PropertyNoWrite: Type = 1;
    pub const PropertyPure: Type = 2;
    pub const PropertyNoreturn: Type = 4;
    pub const PropertyTerminates: Type = 8;
    pub const PropertyNothrow: Type = 16;
    pub const PropertyNaked: Type = 32;
    pub const PropertyMalloc: Type = 64;
    pub const PropertyReturnsTwice: Type = 128;
    pub const PropertyPrivate: Type = 256;
    pub const PropertyAlwaysInline: Type = 512;
    pub const PropertyNoinline: Type = 1024;
    pub const PropertyInlineRecommended: Type = 2048;
    pub const Temporary: Type = 4096;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_asm_constraint {
    pub in_pos: ::std::os::raw::c_int,
    pub out_pos: ::std::os::raw::c_int,
    pub constraint: *mut ident,
    pub mode: *mut ir_mode,
}
#[test]
fn bindgen_test_layout_ir_asm_constraint() {
    assert_eq!(
        ::std::mem::size_of::<ir_asm_constraint>(),
        24usize,
        concat!("Size of: ", stringify!(ir_asm_constraint))
    );
    assert_eq!(
        ::std::mem::align_of::<ir_asm_constraint>(),
        8usize,
        concat!("Alignment of ", stringify!(ir_asm_constraint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ir_asm_constraint>())).in_pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ir_asm_constraint),
            "::",
            stringify!(in_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ir_asm_constraint>())).out_pos as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ir_asm_constraint),
            "::",
            stringify!(out_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ir_asm_constraint>())).constraint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ir_asm_constraint),
            "::",
            stringify!(constraint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ir_asm_constraint>())).mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ir_asm_constraint),
            "::",
            stringify!(mode)
        )
    );
}
pub mod ir_builtin_kind {
    pub type Type = u32;
    pub const Trap: Type = 0;
    pub const Debugbreak: Type = 1;
    pub const ReturnAddress: Type = 2;
    pub const FrameAddress: Type = 3;
    pub const Prefetch: Type = 4;
    pub const Ffs: Type = 5;
    pub const Clz: Type = 6;
    pub const Ctz: Type = 7;
    pub const Popcount: Type = 8;
    pub const Parity: Type = 9;
    pub const Bswap: Type = 10;
    pub const Inport: Type = 11;
    pub const Outport: Type = 12;
    pub const SaturatingIncrement: Type = 13;
    pub const CompareSwap: Type = 14;
    pub const MayAlias: Type = 15;
    pub const VaStart: Type = 16;
    pub const VaArg: Type = 17;
    pub const Last: Type = 17;
}
pub mod ir_volatility {
    pub type Type = u32;
    pub const NonVolatile: Type = 0;
    pub const IsVolatile: Type = 1;
}
pub mod ir_align {
    pub type Type = u32;
    pub const IsAligned: Type = 0;
    pub const NonAligned: Type = 1;
}
pub mod float_int_conversion_overflow_style_t {
    pub type Type = u32;
    pub const Indefinite: Type = 0;
    pub const MinMax: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_entry {
    _unused: [u8; 0],
}
pub type hook_entry_t = hook_entry;
pub type wchar_t = ::std::os::raw::c_int;
pub mod ir_visibility {
    pub type Type = u32;
    pub const External: Type = 0;
    pub const ExternalPrivate: Type = 1;
    pub const ExternalProtected: Type = 2;
    pub const Local: Type = 3;
    pub const Private: Type = 4;
}
pub mod ir_linkage {
    pub type Type = u32;
    pub const Default: Type = 0;
    pub const Constant: Type = 1;
    pub const Weak: Type = 2;
    pub const GarbageCollect: Type = 4;
    pub const Merge: Type = 8;
    pub const HiddenUser: Type = 16;
    pub const NoCodegen: Type = 32;
    pub const NoIdentity: Type = 64;
}
extern "C" {
    pub fn get_entity_visibility(entity: *const ir_entity) -> ir_visibility::Type;
}
extern "C" {
    pub fn set_entity_visibility(entity: *mut ir_entity, visibility: ir_visibility::Type);
}
extern "C" {
    pub fn entity_is_externally_visible(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn entity_has_definition(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn new_entity(owner: *mut ir_type, name: *mut ident, tp: *mut ir_type) -> *mut ir_entity;
}
extern "C" {
    pub fn new_global_entity(
        segment: *mut ir_type,
        ld_name: *mut ident,
        type_: *mut ir_type,
        visibility: ir_visibility::Type,
        linkage: ir_linkage::Type,
    ) -> *mut ir_entity;
}
extern "C" {
    pub fn new_parameter_entity(
        owner: *mut ir_type,
        pos: usize,
        type_: *mut ir_type,
    ) -> *mut ir_entity;
}
extern "C" {
    pub fn new_alias_entity(
        owner: *mut ir_type,
        name: *mut ident,
        alias: *mut ir_entity,
        type_: *mut ir_type,
        visibility: ir_visibility::Type,
    ) -> *mut ir_entity;
}
extern "C" {
    pub fn set_entity_alias(alias: *mut ir_entity, aliased: *mut ir_entity);
}
extern "C" {
    pub fn get_entity_alias(alias: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    pub fn check_entity(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clone_entity(
        old: *const ir_entity,
        name: *mut ident,
        owner: *mut ir_type,
    ) -> *mut ir_entity;
}
extern "C" {
    pub fn free_entity(ent: *mut ir_entity);
}
extern "C" {
    pub fn get_entity_name(ent: *const ir_entity) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_entity_ident(ent: *const ir_entity) -> *mut ident;
}
extern "C" {
    pub fn set_entity_ident(ent: *mut ir_entity, id: *mut ident);
}
extern "C" {
    pub fn get_entity_ld_ident(ent: *const ir_entity) -> *mut ident;
}
extern "C" {
    pub fn set_entity_ld_ident(ent: *mut ir_entity, ld_ident: *mut ident);
}
extern "C" {
    pub fn get_entity_ld_name(ent: *const ir_entity) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn entity_has_ld_ident(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_entity_owner(ent: *const ir_entity) -> *mut ir_type;
}
extern "C" {
    pub fn set_entity_owner(ent: *mut ir_entity, owner: *mut ir_type);
}
extern "C" {
    pub fn get_entity_type(ent: *const ir_entity) -> *mut ir_type;
}
extern "C" {
    pub fn set_entity_type(ent: *mut ir_entity, tp: *mut ir_type);
}
extern "C" {
    pub fn get_entity_linkage(entity: *const ir_entity) -> ir_linkage::Type;
}
extern "C" {
    pub fn set_entity_linkage(entity: *mut ir_entity, linkage: ir_linkage::Type);
}
extern "C" {
    pub fn add_entity_linkage(entity: *mut ir_entity, linkage: ir_linkage::Type);
}
extern "C" {
    pub fn remove_entity_linkage(entity: *mut ir_entity, linkage: ir_linkage::Type);
}
extern "C" {
    pub fn get_entity_volatility(ent: *const ir_entity) -> ir_volatility::Type;
}
extern "C" {
    pub fn set_entity_volatility(ent: *mut ir_entity, vol: ir_volatility::Type);
}
extern "C" {
    pub fn get_volatility_name(var: ir_volatility::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_entity_alignment(entity: *const ir_entity) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_entity_alignment(entity: *mut ir_entity, alignment: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn get_entity_aligned(ent: *const ir_entity) -> ir_align::Type;
}
extern "C" {
    pub fn set_entity_aligned(ent: *mut ir_entity, a: ir_align::Type);
}
extern "C" {
    pub fn get_align_name(a: ir_align::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_entity_offset(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_entity_offset(entity: *mut ir_entity, offset: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_entity_bitfield_offset(entity: *const ir_entity) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_entity_bitfield_offset(entity: *mut ir_entity, offset: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn set_entity_bitfield_size(entity: *mut ir_entity, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn get_entity_bitfield_size(entity: *const ir_entity) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_entity_link(ent: *const ir_entity) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn set_entity_link(ent: *mut ir_entity, l: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn get_entity_irg(ent: *const ir_entity) -> *mut ir_graph;
}
extern "C" {
    pub fn get_entity_linktime_irg(ent: *const ir_entity) -> *mut ir_graph;
}
extern "C" {
    pub fn get_entity_vtable_number(ent: *const ir_entity) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_entity_vtable_number(ent: *mut ir_entity, vtable_number: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn set_entity_label(ent: *mut ir_entity, label: ir_label_t);
}
extern "C" {
    pub fn get_entity_label(ent: *const ir_entity) -> ir_label_t;
}
pub mod ir_entity_usage {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const AddressTaken: Type = 1;
    pub const Write: Type = 2;
    pub const Read: Type = 4;
    pub const ReinterpretCast: Type = 8;
    pub const Unknown: Type = 15;
}
extern "C" {
    pub fn get_entity_usage(ent: *const ir_entity) -> ir_entity_usage::Type;
}
extern "C" {
    pub fn set_entity_usage(ent: *mut ir_entity, flag: ir_entity_usage::Type);
}
extern "C" {
    pub fn get_entity_dbg_info(ent: *const ir_entity) -> *mut dbg_info;
}
extern "C" {
    pub fn set_entity_dbg_info(ent: *mut ir_entity, db: *mut dbg_info);
}
extern "C" {
    pub fn is_parameter_entity(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_entity_parameter_number(entity: *const ir_entity) -> usize;
}
extern "C" {
    pub fn set_entity_parameter_number(entity: *mut ir_entity, n: usize);
}
pub mod ir_initializer_kind_t {
    pub type Type = u32;
    pub const Const: Type = 0;
    pub const Tarval: Type = 1;
    pub const Null: Type = 2;
    pub const Compound: Type = 3;
}
extern "C" {
    pub fn get_initializer_kind(
        initializer: *const ir_initializer_t,
    ) -> ir_initializer_kind_t::Type;
}
extern "C" {
    pub fn get_initializer_kind_name(
        ini: ir_initializer_kind_t::Type,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_initializer_null() -> *mut ir_initializer_t;
}
extern "C" {
    pub fn create_initializer_const(value: *mut ir_node) -> *mut ir_initializer_t;
}
extern "C" {
    pub fn create_initializer_tarval(tv: *mut ir_tarval) -> *mut ir_initializer_t;
}
extern "C" {
    pub fn get_initializer_const_value(initializer: *const ir_initializer_t) -> *mut ir_node;
}
extern "C" {
    pub fn get_initializer_tarval_value(initialzier: *const ir_initializer_t) -> *mut ir_tarval;
}
extern "C" {
    pub fn create_initializer_compound(n_entries: usize) -> *mut ir_initializer_t;
}
extern "C" {
    pub fn get_initializer_compound_n_entries(initializer: *const ir_initializer_t) -> usize;
}
extern "C" {
    pub fn set_initializer_compound_value(
        initializer: *mut ir_initializer_t,
        index: usize,
        value: *mut ir_initializer_t,
    );
}
extern "C" {
    pub fn get_initializer_compound_value(
        initializer: *const ir_initializer_t,
        index: usize,
    ) -> *mut ir_initializer_t;
}
extern "C" {
    pub fn set_entity_initializer(entity: *mut ir_entity, initializer: *mut ir_initializer_t);
}
extern "C" {
    pub fn get_entity_initializer(entity: *const ir_entity) -> *mut ir_initializer_t;
}
extern "C" {
    pub fn add_entity_overwrites(ent: *mut ir_entity, overwritten: *mut ir_entity);
}
extern "C" {
    pub fn get_entity_n_overwrites(ent: *const ir_entity) -> usize;
}
extern "C" {
    pub fn get_entity_overwrites_index(ent: *const ir_entity, overwritten: *mut ir_entity)
        -> usize;
}
extern "C" {
    pub fn get_entity_overwrites(ent: *const ir_entity, pos: usize) -> *mut ir_entity;
}
extern "C" {
    pub fn set_entity_overwrites(ent: *mut ir_entity, pos: usize, overwritten: *mut ir_entity);
}
extern "C" {
    pub fn remove_entity_overwrites(ent: *mut ir_entity, overwritten: *mut ir_entity);
}
extern "C" {
    pub fn get_entity_n_overwrittenby(ent: *const ir_entity) -> usize;
}
extern "C" {
    pub fn get_entity_overwrittenby_index(
        ent: *const ir_entity,
        overwrites: *mut ir_entity,
    ) -> usize;
}
extern "C" {
    pub fn get_entity_overwrittenby(ent: *const ir_entity, pos: usize) -> *mut ir_entity;
}
extern "C" {
    pub fn set_entity_overwrittenby(ent: *mut ir_entity, pos: usize, overwrites: *mut ir_entity);
}
extern "C" {
    pub fn remove_entity_overwrittenby(ent: *mut ir_entity, overwrites: *mut ir_entity);
}
extern "C" {
    pub fn is_compound_entity(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_method_entity(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_alias_entity(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_entity_nr(ent: *const ir_entity) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn get_entity_visited(ent: *const ir_entity) -> ir_visited_t;
}
extern "C" {
    pub fn set_entity_visited(ent: *mut ir_entity, num: ir_visited_t);
}
extern "C" {
    pub fn mark_entity_visited(ent: *mut ir_entity);
}
extern "C" {
    pub fn entity_visited(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn entity_not_visited(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn entity_has_additional_properties(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_entity_additional_properties(
        ent: *const ir_entity,
    ) -> mtp_additional_properties::Type;
}
extern "C" {
    pub fn set_entity_additional_properties(
        ent: *mut ir_entity,
        prop: mtp_additional_properties::Type,
    );
}
extern "C" {
    pub fn add_entity_additional_properties(
        ent: *mut ir_entity,
        flag: mtp_additional_properties::Type,
    );
}
extern "C" {
    pub fn get_unknown_entity() -> *mut ir_entity;
}
extern "C" {
    pub fn is_unknown_entity(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
pub mod ptr_access_kind {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const Read: Type = 1;
    pub const Write: Type = 2;
    pub const Rw: Type = 3;
    pub const Store: Type = 4;
    pub const All: Type = 7;
}
pub mod tp_opcode {
    pub type Type = u32;
    pub const Uninitialized: Type = 0;
    pub const Struct: Type = 1;
    pub const Union: Type = 2;
    pub const Class: Type = 3;
    pub const Segment: Type = 4;
    pub const Method: Type = 5;
    pub const Array: Type = 6;
    pub const Pointer: Type = 7;
    pub const Primitive: Type = 8;
    pub const Code: Type = 9;
    pub const Unknown: Type = 10;
    pub const Last: Type = 10;
}
extern "C" {
    pub fn get_type_opcode_name(opcode: tp_opcode::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn is_SubClass_of(low: *const ir_type, high: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_SubClass_ptr_of(low: *mut ir_type, high: *mut ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_overwritten_by(high: *mut ir_entity, low: *mut ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resolve_ent_polymorphy(
        dynamic_class: *mut ir_type,
        static_ent: *mut ir_entity,
    ) -> *mut ir_entity;
}
pub mod inh_transitive_closure_state {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const Valid: Type = 1;
    pub const Invalid: Type = 2;
    pub const Max: Type = 3;
}
extern "C" {
    pub fn set_irp_inh_transitive_closure_state(s: inh_transitive_closure_state::Type);
}
extern "C" {
    pub fn invalidate_irp_inh_transitive_closure_state();
}
extern "C" {
    pub fn get_irp_inh_transitive_closure_state() -> inh_transitive_closure_state::Type;
}
extern "C" {
    pub fn compute_inh_transitive_closure();
}
extern "C" {
    pub fn free_inh_transitive_closure();
}
extern "C" {
    pub fn get_class_trans_subtype_first(tp: *const ir_type) -> *mut ir_type;
}
extern "C" {
    pub fn get_class_trans_subtype_next(tp: *const ir_type) -> *mut ir_type;
}
extern "C" {
    pub fn is_class_trans_subtype(
        tp: *const ir_type,
        subtp: *const ir_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_class_trans_supertype_first(tp: *const ir_type) -> *mut ir_type;
}
extern "C" {
    pub fn get_class_trans_supertype_next(tp: *const ir_type) -> *mut ir_type;
}
extern "C" {
    pub fn get_entity_trans_overwrittenby_first(ent: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    pub fn get_entity_trans_overwrittenby_next(ent: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    pub fn get_entity_trans_overwrites_first(ent: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    pub fn get_entity_trans_overwrites_next(ent: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    pub fn check_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tr_verify() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_type(tp: *mut ir_type);
}
extern "C" {
    pub fn get_type_opcode(type_: *const ir_type) -> tp_opcode::Type;
}
extern "C" {
    pub fn ir_print_type(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        tp: *const ir_type,
    );
}
pub mod ir_type_state {
    pub type Type = u32;
    pub const Undefined: Type = 0;
    pub const Fixed: Type = 1;
}
extern "C" {
    pub fn get_type_state_name(s: ir_type_state::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_type_state(tp: *const ir_type) -> ir_type_state::Type;
}
extern "C" {
    pub fn set_type_state(tp: *mut ir_type, state: ir_type_state::Type);
}
extern "C" {
    pub fn get_type_mode(tp: *const ir_type) -> *mut ir_mode;
}
extern "C" {
    pub fn get_type_size(tp: *const ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_type_size(tp: *mut ir_type, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn get_type_alignment(tp: *const ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_type_alignment(tp: *mut ir_type, align: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn get_type_visited(tp: *const ir_type) -> ir_visited_t;
}
extern "C" {
    pub fn set_type_visited(tp: *mut ir_type, num: ir_visited_t);
}
extern "C" {
    pub fn mark_type_visited(tp: *mut ir_type);
}
extern "C" {
    pub fn type_visited(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_type_link(tp: *const ir_type) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn set_type_link(tp: *mut ir_type, l: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn inc_master_type_visited();
}
extern "C" {
    pub fn set_master_type_visited(val: ir_visited_t);
}
extern "C" {
    pub fn get_master_type_visited() -> ir_visited_t;
}
extern "C" {
    pub fn set_type_dbg_info(tp: *mut ir_type, db: *mut type_dbg_info);
}
extern "C" {
    pub fn get_type_dbg_info(tp: *const ir_type) -> *mut type_dbg_info;
}
extern "C" {
    pub fn get_type_nr(tp: *const ir_type) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn new_type_class(name: *mut ident) -> *mut ir_type;
}
extern "C" {
    pub fn get_class_n_members(clss: *const ir_type) -> usize;
}
extern "C" {
    pub fn get_class_member(clss: *const ir_type, pos: usize) -> *mut ir_entity;
}
extern "C" {
    pub fn get_class_member_index(clss: *const ir_type, mem: *const ir_entity) -> usize;
}
extern "C" {
    pub fn add_class_subtype(clss: *mut ir_type, subtype: *mut ir_type);
}
extern "C" {
    pub fn get_class_n_subtypes(clss: *const ir_type) -> usize;
}
extern "C" {
    pub fn get_class_subtype(clss: *const ir_type, pos: usize) -> *mut ir_type;
}
extern "C" {
    pub fn get_class_subtype_index(clss: *const ir_type, subclass: *const ir_type) -> usize;
}
extern "C" {
    pub fn set_class_subtype(clss: *mut ir_type, subtype: *mut ir_type, pos: usize);
}
extern "C" {
    pub fn remove_class_subtype(clss: *mut ir_type, subtype: *mut ir_type);
}
extern "C" {
    pub fn add_class_supertype(clss: *mut ir_type, supertype: *mut ir_type);
}
extern "C" {
    pub fn get_class_n_supertypes(clss: *const ir_type) -> usize;
}
extern "C" {
    pub fn get_class_supertype_index(clss: *const ir_type, super_clss: *const ir_type) -> usize;
}
extern "C" {
    pub fn get_class_supertype(clss: *const ir_type, pos: usize) -> *mut ir_type;
}
extern "C" {
    pub fn set_class_supertype(clss: *mut ir_type, supertype: *mut ir_type, pos: usize);
}
extern "C" {
    pub fn remove_class_supertype(clss: *mut ir_type, supertype: *mut ir_type);
}
extern "C" {
    pub fn is_Class_type(clss: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn new_type_struct(name: *mut ident) -> *mut ir_type;
}
extern "C" {
    pub fn get_struct_n_members(strct: *const ir_type) -> usize;
}
extern "C" {
    pub fn get_struct_member(strct: *const ir_type, pos: usize) -> *mut ir_entity;
}
extern "C" {
    pub fn get_struct_member_index(strct: *const ir_type, member: *const ir_entity) -> usize;
}
extern "C" {
    pub fn is_Struct_type(strct: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn new_type_union(name: *mut ident) -> *mut ir_type;
}
extern "C" {
    pub fn get_union_n_members(uni: *const ir_type) -> usize;
}
extern "C" {
    pub fn get_union_member(uni: *const ir_type, pos: usize) -> *mut ir_entity;
}
extern "C" {
    pub fn get_union_member_index(uni: *const ir_type, member: *const ir_entity) -> usize;
}
extern "C" {
    pub fn is_Union_type(uni: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn new_type_method(
        n_param: usize,
        n_res: usize,
        is_variadic: ::std::os::raw::c_int,
        cc_mask: ::std::os::raw::c_uint,
        property_mask: mtp_additional_properties::Type,
    ) -> *mut ir_type;
}
extern "C" {
    pub fn get_method_n_params(method: *const ir_type) -> usize;
}
extern "C" {
    pub fn get_method_param_type(method: *const ir_type, pos: usize) -> *mut ir_type;
}
extern "C" {
    pub fn set_method_param_type(method: *mut ir_type, pos: usize, tp: *mut ir_type);
}
extern "C" {
    pub fn get_method_n_ress(method: *const ir_type) -> usize;
}
extern "C" {
    pub fn get_method_res_type(method: *const ir_type, pos: usize) -> *mut ir_type;
}
extern "C" {
    pub fn set_method_res_type(method: *mut ir_type, pos: usize, tp: *mut ir_type);
}
extern "C" {
    pub fn is_method_variadic(method: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_method_additional_properties(
        method: *const ir_type,
    ) -> mtp_additional_properties::Type;
}
pub mod calling_convention {
    pub type Type = u32;
    pub const RegParam: Type = 16777216;
    pub const LastOnTop: Type = 33554432;
    pub const CalleeClearStk: Type = 67108864;
    pub const ThisCall: Type = 134217728;
    pub const CompoundRet: Type = 268435456;
    pub const FrameOnCallerStk: Type = 536870912;
    pub const FpregParam: Type = 1073741824;
}
extern "C" {
    pub fn get_method_calling_convention(method: *const ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_method_n_regparams(method: *mut ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn is_Method_type(method: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn new_type_array(
        element_type: *mut ir_type,
        n_elements: ::std::os::raw::c_uint,
    ) -> *mut ir_type;
}
extern "C" {
    pub fn get_array_size(array: *const ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_array_element_type(array: *const ir_type) -> *mut ir_type;
}
extern "C" {
    pub fn is_Array_type(array: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn new_type_pointer(points_to: *mut ir_type) -> *mut ir_type;
}
extern "C" {
    pub fn set_pointer_points_to_type(pointer: *mut ir_type, tp: *mut ir_type);
}
extern "C" {
    pub fn get_pointer_points_to_type(pointer: *const ir_type) -> *mut ir_type;
}
extern "C" {
    pub fn is_Pointer_type(pointer: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn new_type_primitive(mode: *mut ir_mode) -> *mut ir_type;
}
extern "C" {
    pub fn is_Primitive_type(primitive: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_code_type() -> *mut ir_type;
}
extern "C" {
    pub fn is_code_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_unknown_type() -> *mut ir_type;
}
extern "C" {
    pub fn is_unknown_type(type_: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_atomic_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_compound_ident(tp: *const ir_type) -> *mut ident;
}
extern "C" {
    pub fn get_compound_name(tp: *const ir_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_compound_n_members(tp: *const ir_type) -> usize;
}
extern "C" {
    pub fn get_compound_member(tp: *const ir_type, pos: usize) -> *mut ir_entity;
}
extern "C" {
    pub fn get_compound_member_index(tp: *const ir_type, member: *const ir_entity) -> usize;
}
extern "C" {
    pub fn remove_compound_member(compound: *mut ir_type, entity: *mut ir_entity);
}
extern "C" {
    pub fn default_layout_compound_type(tp: *mut ir_type);
}
extern "C" {
    pub fn is_compound_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn new_type_frame() -> *mut ir_type;
}
extern "C" {
    pub fn is_frame_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clone_frame_type(type_: *mut ir_type) -> *mut ir_type;
}
extern "C" {
    pub fn is_segment_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
pub type compare_types_func_t = ::std::option::Option<
    unsafe extern "C" fn(tp1: *const ::std::os::raw::c_void, tp2: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
pub type type_walk_func = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *mut ir_type,
        entity: *mut ir_entity,
        env: *mut ::std::os::raw::c_void,
    ),
>;
pub type class_walk_func = ::std::option::Option<
    unsafe extern "C" fn(clss: *mut ir_type, env: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn type_walk(pre: type_walk_func, post: type_walk_func, env: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn type_walk_irg(
        irg: *mut ir_graph,
        pre: type_walk_func,
        post: type_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn type_walk_super2sub(
        pre: type_walk_func,
        post: type_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn type_walk_super(
        pre: type_walk_func,
        post: type_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn class_walk_super2sub(
        pre: class_walk_func,
        post: class_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
pub type entity_walk_func = ::std::option::Option<
    unsafe extern "C" fn(ent: *mut ir_entity, env: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn walk_types_entities(
        tp: *mut ir_type,
        doit: entity_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn get_method_param_access(ent: *mut ir_entity, pos: usize) -> ptr_access_kind::Type;
}
extern "C" {
    pub fn analyze_irg_args(irg: *mut ir_graph);
}
extern "C" {
    pub fn get_method_param_weight(ent: *mut ir_entity, pos: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn analyze_irg_args_weight(irg: *mut ir_graph);
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub mod __codecvt_result {
    pub type Type = u32;
    pub const Ok: Type = 0;
    pub const Partial: Type = 1;
    pub const Error: Type = 2;
    pub const Noconv: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn optimize_cf(irg: *mut ir_graph);
}
extern "C" {
    pub fn opt_jumpthreading(irg: *mut ir_graph);
}
extern "C" {
    pub fn opt_bool(irg: *mut ir_graph);
}
extern "C" {
    pub fn conv_opt(irg: *mut ir_graph);
}
pub type check_alloc_entity_func =
    ::std::option::Option<unsafe extern "C" fn(ent: *mut ir_entity) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn optimize_funccalls();
}
extern "C" {
    pub fn do_gvn_pre(irg: *mut ir_graph);
}
pub type arch_allow_ifconv_func = ::std::option::Option<
    unsafe extern "C" fn(sel: *const ir_node, mux_false: *const ir_node, mux_true: *const ir_node)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn opt_if_conv(irg: *mut ir_graph);
}
extern "C" {
    pub fn opt_if_conv_cb(irg: *mut ir_graph, callback: arch_allow_ifconv_func);
}
extern "C" {
    pub fn opt_parallelize_mem(irg: *mut ir_graph);
}
extern "C" {
    pub fn can_replace_load_by_const(load: *const ir_node, c: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn optimize_load_store(irg: *mut ir_graph);
}
extern "C" {
    pub fn combine_memops(irg: *mut ir_graph);
}
extern "C" {
    pub fn opt_ldst(irg: *mut ir_graph);
}
extern "C" {
    pub fn opt_frame_irg(irg: *mut ir_graph);
}
pub mod osr_flags {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const LftrWithOvCheck: Type = 1;
    pub const IgnoreX86Shift: Type = 2;
    pub const KeepRegPressure: Type = 4;
}
extern "C" {
    pub fn opt_osr(irg: *mut ir_graph, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn remove_phi_cycles(irg: *mut ir_graph);
}
extern "C" {
    pub fn proc_cloning(threshold: f32);
}
extern "C" {
    pub fn optimize_reassociation(irg: *mut ir_graph);
}
extern "C" {
    pub fn normalize_one_return(irg: *mut ir_graph);
}
extern "C" {
    pub fn normalize_n_returns(irg: *mut ir_graph);
}
extern "C" {
    pub fn scalar_replacement_opt(irg: *mut ir_graph);
}
extern "C" {
    pub fn opt_tail_rec_irg(irg: *mut ir_graph);
}
extern "C" {
    pub fn combo(irg: *mut ir_graph);
}
pub type opt_ptr = ::std::option::Option<unsafe extern "C" fn(irg: *mut ir_graph)>;
extern "C" {
    pub fn inline_functions(
        maxsize: ::std::os::raw::c_uint,
        inline_threshold: ::std::os::raw::c_int,
        after_inline_opt: opt_ptr,
    );
}
extern "C" {
    pub fn shape_blocks(irg: *mut ir_graph);
}
extern "C" {
    pub fn do_loop_inversion(irg: *mut ir_graph);
}
extern "C" {
    pub fn do_loop_unrolling(irg: *mut ir_graph);
}
extern "C" {
    pub fn do_loop_peeling(irg: *mut ir_graph);
}
extern "C" {
    pub fn garbage_collect_entities();
}
extern "C" {
    pub fn dead_node_elimination(irg: *mut ir_graph);
}
extern "C" {
    pub fn place_code(irg: *mut ir_graph);
}
extern "C" {
    pub fn occult_consts(arg1: *mut ir_graph);
}
extern "C" {
    pub fn value_not_null(n: *const ir_node, confirm: *mut *const ir_node)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn computed_value_Cmp_Confirm(
        left: *mut ir_node,
        right: *mut ir_node,
        relation: ir_relation::Type,
    ) -> *mut ir_tarval;
}
extern "C" {
    pub fn create_compilerlib_entity(
        name: *const ::std::os::raw::c_char,
        mt: *mut ir_type,
    ) -> *mut ir_entity;
}
pub mod ir_mode_arithmetic {
    pub type Type = u32;
    pub const None: Type = 1;
    pub const TwosComplement: Type = 2;
    pub const Ieee754: Type = 256;
    pub const X86ExtendedFloat: Type = 257;
    pub const Last: Type = 257;
}
extern "C" {
    pub fn new_int_mode(
        name: *const ::std::os::raw::c_char,
        bit_size: ::std::os::raw::c_uint,
        sign: ::std::os::raw::c_int,
        modulo_shift: ::std::os::raw::c_uint,
    ) -> *mut ir_mode;
}
extern "C" {
    pub fn new_reference_mode(
        name: *const ::std::os::raw::c_char,
        bit_size: ::std::os::raw::c_uint,
        modulo_shift: ::std::os::raw::c_uint,
    ) -> *mut ir_mode;
}
extern "C" {
    pub fn new_float_mode(
        name: *const ::std::os::raw::c_char,
        arithmetic: ir_mode_arithmetic::Type,
        exponent_size: ::std::os::raw::c_uint,
        mantissa_size: ::std::os::raw::c_uint,
        int_conv_overflow: float_int_conversion_overflow_style_t::Type,
    ) -> *mut ir_mode;
}
extern "C" {
    pub fn new_non_arithmetic_mode(
        name: *const ::std::os::raw::c_char,
        bit_size: ::std::os::raw::c_uint,
    ) -> *mut ir_mode;
}
extern "C" {
    pub fn get_mode_ident(mode: *const ir_mode) -> *mut ident;
}
extern "C" {
    pub fn get_mode_name(mode: *const ir_mode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_mode_size_bits(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_mode_size_bytes(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_mode_arithmetic(mode: *const ir_mode) -> ir_mode_arithmetic::Type;
}
extern "C" {
    pub fn get_mode_modulo_shift(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_mode_min(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn get_mode_max(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn get_mode_null(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn get_mode_one(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn get_mode_all_one(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn get_mode_infinite(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[link_name = "\u{1}mode_M"]
    pub static mut mode_M: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_F"]
    pub static mut mode_F: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_D"]
    pub static mut mode_D: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_Bs"]
    pub static mut mode_Bs: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_Bu"]
    pub static mut mode_Bu: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_Hs"]
    pub static mut mode_Hs: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_Hu"]
    pub static mut mode_Hu: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_Is"]
    pub static mut mode_Is: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_Iu"]
    pub static mut mode_Iu: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_Ls"]
    pub static mut mode_Ls: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_Lu"]
    pub static mut mode_Lu: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_P"]
    pub static mut mode_P: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_b"]
    pub static mut mode_b: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_X"]
    pub static mut mode_X: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_BB"]
    pub static mut mode_BB: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_T"]
    pub static mut mode_T: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_ANY"]
    pub static mut mode_ANY: *mut ir_mode;
}
extern "C" {
    #[link_name = "\u{1}mode_BAD"]
    pub static mut mode_BAD: *mut ir_mode;
}
extern "C" {
    pub fn get_modeF() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeD() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeBs() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeBu() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeHs() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeHu() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeIs() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeIu() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeLs() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeLu() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeP() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeb() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeX() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeBB() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeM() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeT() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeANY() -> *mut ir_mode;
}
extern "C" {
    pub fn get_modeBAD() -> *mut ir_mode;
}
extern "C" {
    pub fn set_modeP(p: *mut ir_mode);
}
extern "C" {
    pub fn mode_is_signed(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mode_is_float(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mode_is_int(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mode_is_reference(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mode_is_num(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mode_is_data(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smaller_mode(sm: *const ir_mode, lm: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn values_in_mode(sm: *const ir_mode, lm: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_unsigned_mode(mode: *const ir_mode) -> *mut ir_mode;
}
extern "C" {
    pub fn find_signed_mode(mode: *const ir_mode) -> *mut ir_mode;
}
extern "C" {
    pub fn find_double_bits_int_mode(mode: *const ir_mode) -> *mut ir_mode;
}
extern "C" {
    pub fn mode_has_signed_zero(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mode_overflow_on_unary_Minus(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mode_wrap_around(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_reference_offset_mode(mode: *const ir_mode) -> *mut ir_mode;
}
extern "C" {
    pub fn set_reference_offset_mode(ref_mode: *mut ir_mode, int_mode: *mut ir_mode);
}
extern "C" {
    pub fn get_mode_mantissa_size(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_mode_exponent_size(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_mode_float_int_overflow(
        mode: *const ir_mode,
    ) -> float_int_conversion_overflow_style_t::Type;
}
extern "C" {
    pub fn is_reinterpret_cast(src: *const ir_mode, dst: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_type_for_mode(mode: *const ir_mode) -> *mut ir_type;
}
extern "C" {
    pub fn ir_get_n_modes() -> usize;
}
extern "C" {
    pub fn ir_get_mode(num: usize) -> *mut ir_mode;
}
pub mod asm_constraint_flags_t {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const SupportsRegister: Type = 1;
    pub const SupportsMemop: Type = 2;
    pub const SupportsImmediate: Type = 4;
    pub const SupportsAny: Type = 7;
    pub const NoSupport: Type = 8;
    pub const ModifierWrite: Type = 16;
    pub const ModifierRead: Type = 32;
    pub const ModifierEarlyclobber: Type = 64;
    pub const ModifierCommutative: Type = 128;
    pub const Invalid: Type = 256;
}
pub mod dwarf_source_language {
    pub type Type = u32;
    pub const C89: Type = 1;
    pub const C: Type = 2;
    pub const Ada83: Type = 3;
    pub const CPlusPlus: Type = 4;
    pub const Cobol74: Type = 5;
    pub const Cobol85: Type = 6;
    pub const Fortran77: Type = 7;
    pub const Fortran90: Type = 8;
    pub const Pascal83: Type = 9;
    pub const Modula2: Type = 10;
    pub const Java: Type = 11;
    pub const C99: Type = 12;
    pub const Ada95: Type = 13;
    pub const Fortran95: Type = 14;
    pub const Pli: Type = 15;
    pub const ObjC: Type = 16;
    pub const ObjCPlusPlus: Type = 17;
    pub const Upc: Type = 18;
    pub const D: Type = 19;
    pub const Python: Type = 20;
    pub const Go: Type = 22;
}
extern "C" {
    pub fn be_lower_for_target();
}
pub type after_transform_func = ::std::option::Option<
    unsafe extern "C" fn(irg: *mut ir_graph, name: *const ::std::os::raw::c_char),
>;
extern "C" {
    pub fn be_set_after_transform_func(func: after_transform_func);
}
extern "C" {
    pub fn be_main(output: *mut FILE, compilation_unit_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn be_parse_asm_constraints(
        constraints: *const ::std::os::raw::c_char,
    ) -> asm_constraint_flags_t::Type;
}
extern "C" {
    pub fn be_is_valid_clobber(clobber: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn be_dwarf_set_source_language(language: dwarf_source_language::Type);
}
extern "C" {
    pub fn be_dwarf_set_compilation_directory(directory: *const ::std::os::raw::c_char);
}
pub mod irp_callgraph_state {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const Consistent: Type = 1;
    pub const Inconsistent: Type = 2;
    pub const AndCalltreeConsistent: Type = 3;
}
extern "C" {
    pub fn get_irp_callgraph_state() -> irp_callgraph_state::Type;
}
extern "C" {
    pub fn set_irp_callgraph_state(s: irp_callgraph_state::Type);
}
extern "C" {
    pub fn get_irg_n_callers(irg: *const ir_graph) -> usize;
}
extern "C" {
    pub fn get_irg_caller(irg: *const ir_graph, pos: usize) -> *mut ir_graph;
}
extern "C" {
    pub fn is_irg_caller_backedge(irg: *const ir_graph, pos: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn has_irg_caller_backedge(irg: *const ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_irg_caller_loop_depth(irg: *const ir_graph, pos: usize) -> usize;
}
extern "C" {
    pub fn get_irg_n_callees(irg: *const ir_graph) -> usize;
}
extern "C" {
    pub fn get_irg_callee(irg: *const ir_graph, pos: usize) -> *mut ir_graph;
}
extern "C" {
    pub fn is_irg_callee_backedge(irg: *const ir_graph, pos: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn has_irg_callee_backedge(irg: *const ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_irg_callee_loop_depth(irg: *const ir_graph, pos: usize) -> usize;
}
extern "C" {
    pub fn get_irg_method_execution_frequency(irg: *const ir_graph) -> f64;
}
extern "C" {
    pub fn compute_callgraph();
}
extern "C" {
    pub fn free_callgraph();
}
pub type callgraph_walk_func =
    ::std::option::Option<unsafe extern "C" fn(g: *mut ir_graph, env: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn callgraph_walk(
        pre: callgraph_walk_func,
        post: callgraph_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn find_callgraph_recursions();
}
extern "C" {
    pub fn analyse_loop_nesting_depth();
}
pub mod loop_nesting_depth_state {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const Consistent: Type = 1;
    pub const Inconsistent: Type = 2;
}
extern "C" {
    pub fn get_irp_loop_nesting_depth_state() -> loop_nesting_depth_state::Type;
}
extern "C" {
    pub fn set_irp_loop_nesting_depth_state(s: loop_nesting_depth_state::Type);
}
extern "C" {
    pub fn set_irp_loop_nesting_depth_state_inconsistent();
}
extern "C" {
    pub fn compute_cdep(irg: *mut ir_graph);
}
extern "C" {
    pub fn free_cdep(irg: *mut ir_graph);
}
extern "C" {
    pub fn get_cdep_node(cdep: *const ir_cdep) -> *mut ir_node;
}
extern "C" {
    pub fn get_cdep_next(cdep: *const ir_cdep) -> *mut ir_cdep;
}
extern "C" {
    pub fn find_cdep(block: *const ir_node) -> *mut ir_cdep;
}
extern "C" {
    pub fn exchange_cdep(old: *mut ir_node, nw: *const ir_node);
}
extern "C" {
    pub fn is_cdep_on(dependee: *const ir_node, candidate: *const ir_node)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_unique_cdep(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn has_multiple_cdep(block: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgana(free_methods: *mut *mut *mut ir_entity) -> usize;
}
extern "C" {
    pub fn free_callee_info(irg: *mut ir_graph);
}
extern "C" {
    pub fn free_irp_callee_info();
}
extern "C" {
    pub fn opt_call_addrs();
}
extern "C" {
    pub fn cg_call_has_callees(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_get_call_n_callees(node: *const ir_node) -> usize;
}
extern "C" {
    pub fn cg_get_call_callee(node: *const ir_node, pos: usize) -> *mut ir_entity;
}
extern "C" {
    pub fn cg_set_call_callee_arr(node: *mut ir_node, n: usize, arr: *mut *mut ir_entity);
}
extern "C" {
    pub fn cg_remove_call_callee_arr(node: *mut ir_node);
}
pub mod dbg_action {
    pub type Type = u32;
    pub const Error: Type = 0;
    pub const OptSsa: Type = 1;
    pub const OptAuxnode: Type = 2;
    pub const ConstEval: Type = 3;
    pub const OptCse: Type = 4;
    pub const Straightening: Type = 5;
    pub const IfSimplification: Type = 6;
    pub const AlgebraicSimplification: Type = 7;
    pub const WriteAfterWrite: Type = 8;
    pub const WriteAfterRead: Type = 9;
    pub const ReadAfterWrite: Type = 10;
    pub const ReadAfterRead: Type = 11;
    pub const ReadAConst: Type = 12;
    pub const DeadCode: Type = 13;
    pub const OptConfirm: Type = 14;
    pub const GvnPre: Type = 15;
    pub const Combo: Type = 16;
    pub const Jumpthreading: Type = 17;
    pub const Backend: Type = 18;
    pub const Max: Type = 19;
}
extern "C" {
    pub fn dbg_action_2_str(a: dbg_action::Type) -> *const ::std::os::raw::c_char;
}
pub type merge_pair_func = ::std::option::Option<
    unsafe extern "C" fn(new_node: *mut ir_node, old_node: *mut ir_node, action: dbg_action::Type),
>;
pub type merge_sets_func = ::std::option::Option<
    unsafe extern "C" fn(
        new_node_array: *const *mut ir_node,
        new_num_entries: ::std::os::raw::c_int,
        old_node_array: *const *mut ir_node,
        old_num_entries: ::std::os::raw::c_int,
        action: dbg_action::Type,
    ),
>;
extern "C" {
    pub fn dbg_init(dbg_info_merge_pair: merge_pair_func, dbg_info_merge_sets: merge_sets_func);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct src_loc_t {
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_uint,
    pub column: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_src_loc_t() {
    assert_eq!(
        ::std::mem::size_of::<src_loc_t>(),
        16usize,
        concat!("Size of: ", stringify!(src_loc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<src_loc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(src_loc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<src_loc_t>())).file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(src_loc_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<src_loc_t>())).line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(src_loc_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<src_loc_t>())).column as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(src_loc_t),
            "::",
            stringify!(column)
        )
    );
}
pub type retrieve_dbg_func =
    ::std::option::Option<unsafe extern "C" fn(dbg: *const dbg_info) -> src_loc_t>;
extern "C" {
    pub fn ir_set_debug_retrieve(func: retrieve_dbg_func);
}
pub type retrieve_type_dbg_func = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        tdbgi: *const type_dbg_info,
    ),
>;
extern "C" {
    pub fn ir_set_type_debug_retrieve(func: retrieve_type_dbg_func);
}
extern "C" {
    pub fn ir_retrieve_dbg_info(dbg: *const dbg_info) -> src_loc_t;
}
extern "C" {
    pub fn ir_retrieve_type_dbg_info(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        tdbgi: *const type_dbg_info,
    );
}
extern "C" {
    pub fn ir_estimate_execfreq(irg: *mut ir_graph);
}
extern "C" {
    pub fn get_block_execfreq(block: *const ir_node) -> f64;
}
extern "C" {
    pub fn ir_init();
}
extern "C" {
    pub fn ir_init_library();
}
extern "C" {
    pub fn ir_finish();
}
extern "C" {
    pub fn ir_get_version_major() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_get_version_minor() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_get_version_micro() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_get_version_revision() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_get_version_build() -> *const ::std::os::raw::c_char;
}
pub mod firm_kind {
    pub type Type = u32;
    pub const Bad: Type = 0;
    pub const Entity: Type = 1;
    pub const Type: Type = 2;
    pub const IrGraph: Type = 3;
    pub const IrNode: Type = 4;
    pub const IrMode: Type = 5;
    pub const Tarval: Type = 6;
    pub const IrLoop: Type = 7;
    pub const IrMax: Type = 8;
}
extern "C" {
    pub fn get_kind(firm_thing: *const ::std::os::raw::c_void) -> firm_kind::Type;
}
extern "C" {
    pub fn get_irn_height(h: *const ir_heights_t, irn: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn heights_reachable_in_block(
        h: *mut ir_heights_t,
        src: *const ir_node,
        tgt: *const ir_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heights_recompute_block(
        h: *mut ir_heights_t,
        block: *mut ir_node,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn heights_new(irg: *mut ir_graph) -> *mut ir_heights_t;
}
extern "C" {
    pub fn heights_free(h: *mut ir_heights_t);
}
extern "C" {
    pub fn new_id_from_str(str: *const ::std::os::raw::c_char) -> *mut ident;
}
extern "C" {
    pub fn new_id_from_chars(str: *const ::std::os::raw::c_char, len: usize) -> *mut ident;
}
extern "C" {
    pub fn new_id_fmt(fmt: *const ::std::os::raw::c_char, ...) -> *mut ident;
}
extern "C" {
    pub fn get_id_str(id: *mut ident) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn id_unique(tag: *const ::std::os::raw::c_char) -> *mut ident;
}
extern "C" {
    pub fn gc_irgs(n_keep: usize, keep_arr: *mut *mut ir_entity);
}
pub mod op_arity {
    pub type Type = u32;
    pub const Invalid: Type = 0;
    pub const Binary: Type = 1;
    pub const Dynamic: Type = 2;
    pub const Any: Type = 3;
}
pub mod irop_flags {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const Commutative: Type = 1;
    pub const Cfopcode: Type = 2;
    pub const Fragile: Type = 4;
    pub const Forking: Type = 8;
    pub const Constlike: Type = 32;
    pub const Keep: Type = 64;
    pub const StartBlock: Type = 128;
    pub const UsesMemory: Type = 256;
    pub const DumpNoblock: Type = 512;
    pub const UnknownJump: Type = 2048;
    pub const ConstMemory: Type = 4096;
}
extern "C" {
    pub fn get_op_name(op: *const ir_op) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_op_code(op: *const ir_op) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_op_pin_state_name(s: op_pin_state::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_op_pinned(op: *const ir_op) -> op_pin_state::Type;
}
extern "C" {
    pub fn get_next_ir_opcode() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_next_ir_opcodes(num: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
pub type op_func = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn get_generic_function_ptr(op: *const ir_op) -> op_func;
}
extern "C" {
    pub fn set_generic_function_ptr(op: *mut ir_op, func: op_func);
}
extern "C" {
    pub fn get_op_flags(op: *const ir_op) -> irop_flags::Type;
}
pub type hash_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *const ir_node) -> ::std::os::raw::c_uint>;
pub type computed_value_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *const ir_node) -> *mut ir_tarval>;
pub type equivalent_node_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ir_node) -> *mut ir_node>;
pub type transform_node_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ir_node) -> *mut ir_node>;
pub type node_attrs_equal_func = ::std::option::Option<
    unsafe extern "C" fn(a: *const ir_node, b: *const ir_node) -> ::std::os::raw::c_int,
>;
pub type reassociate_func =
    ::std::option::Option<unsafe extern "C" fn(n: *mut *mut ir_node) -> ::std::os::raw::c_int>;
pub type copy_attr_func = ::std::option::Option<
    unsafe extern "C" fn(irg: *mut ir_graph, old_node: *const ir_node, new_node: *mut ir_node),
>;
pub type get_type_attr_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *const ir_node) -> *mut ir_type>;
pub type get_entity_attr_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *const ir_node) -> *mut ir_entity>;
pub type verify_node_func =
    ::std::option::Option<unsafe extern "C" fn(node: *const ir_node) -> ::std::os::raw::c_int>;
pub type verify_proj_node_func =
    ::std::option::Option<unsafe extern "C" fn(proj: *const ir_node) -> ::std::os::raw::c_int>;
pub mod dump_reason_t {
    pub type Type = u32;
    pub const OpcodeTxt: Type = 0;
    pub const ModeTxt: Type = 1;
    pub const NodeattrTxt: Type = 2;
    pub const InfoTxt: Type = 3;
}
pub type dump_node_func = ::std::option::Option<
    unsafe extern "C" fn(out: *mut FILE, self_: *const ir_node, reason: dump_reason_t::Type),
>;
extern "C" {
    pub fn set_op_hash(op: *mut ir_op, func: hash_func);
}
extern "C" {
    pub fn set_op_computed_value(op: *mut ir_op, func: computed_value_func);
}
extern "C" {
    pub fn set_op_computed_value_proj(op: *mut ir_op, func: computed_value_func);
}
extern "C" {
    pub fn set_op_equivalent_node(op: *mut ir_op, func: equivalent_node_func);
}
extern "C" {
    pub fn set_op_equivalent_node_proj(op: *mut ir_op, func: equivalent_node_func);
}
extern "C" {
    pub fn set_op_transform_node(op: *mut ir_op, func: transform_node_func);
}
extern "C" {
    pub fn set_op_transform_node_proj(op: *mut ir_op, func: transform_node_func);
}
extern "C" {
    pub fn set_op_attrs_equal(op: *mut ir_op, func: node_attrs_equal_func);
}
extern "C" {
    pub fn set_op_reassociate(op: *mut ir_op, func: reassociate_func);
}
extern "C" {
    pub fn set_op_copy_attr(op: *mut ir_op, func: copy_attr_func);
}
extern "C" {
    pub fn set_op_get_type_attr(op: *mut ir_op, func: get_type_attr_func);
}
extern "C" {
    pub fn set_op_get_entity_attr(op: *mut ir_op, func: get_entity_attr_func);
}
extern "C" {
    pub fn set_op_verify(op: *mut ir_op, func: verify_node_func);
}
extern "C" {
    pub fn set_op_verify_proj(op: *mut ir_op, func: verify_proj_node_func);
}
extern "C" {
    pub fn set_op_dump(op: *mut ir_op, func: dump_node_func);
}
extern "C" {
    pub fn new_ir_op(
        code: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        p: op_pin_state::Type,
        flags: irop_flags::Type,
        opar: op_arity::Type,
        op_index: ::std::os::raw::c_int,
        attr_size: usize,
    ) -> *mut ir_op;
}
extern "C" {
    pub fn free_ir_op(code: *mut ir_op);
}
extern "C" {
    pub fn ir_get_n_opcodes() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_get_opcode(code: ::std::os::raw::c_uint) -> *mut ir_op;
}
extern "C" {
    pub fn ir_clear_opcodes_generic_func();
}
extern "C" {
    pub fn ir_op_set_memory_index(op: *mut ir_op, memory_index: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ir_op_set_fragile_indices(
        op: *mut ir_op,
        pn_x_regular: ::std::os::raw::c_uint,
        pn_x_except: ::std::os::raw::c_uint,
    );
}
pub mod ir_opcode {
    pub type Type = u32;
    pub const Asm: Type = 0;
    pub const Add: Type = 1;
    pub const Address: Type = 2;
    pub const Align: Type = 3;
    pub const Alloc: Type = 4;
    pub const Anchor: Type = 5;
    pub const And: Type = 6;
    pub const Bad: Type = 7;
    pub const Bitcast: Type = 8;
    pub const Block: Type = 9;
    pub const Builtin: Type = 10;
    pub const Call: Type = 11;
    pub const Cmp: Type = 12;
    pub const Cond: Type = 13;
    pub const Confirm: Type = 14;
    pub const Const: Type = 15;
    pub const Conv: Type = 16;
    pub const CopyB: Type = 17;
    pub const Deleted: Type = 18;
    pub const Div: Type = 19;
    pub const Dummy: Type = 20;
    pub const End: Type = 21;
    pub const Eor: Type = 22;
    pub const Free: Type = 23;
    pub const Ijmp: Type = 24;
    pub const Id: Type = 25;
    pub const Jmp: Type = 26;
    pub const Load: Type = 27;
    pub const Member: Type = 28;
    pub const Minus: Type = 29;
    pub const Mod: Type = 30;
    pub const Mul: Type = 31;
    pub const Mulh: Type = 32;
    pub const Mux: Type = 33;
    pub const NoMem: Type = 34;
    pub const Not: Type = 35;
    pub const Offset: Type = 36;
    pub const Or: Type = 37;
    pub const Phi: Type = 38;
    pub const Pin: Type = 39;
    pub const Proj: Type = 40;
    pub const Raise: Type = 41;
    pub const Return: Type = 42;
    pub const Sel: Type = 43;
    pub const Shl: Type = 44;
    pub const Shr: Type = 45;
    pub const Shrs: Type = 46;
    pub const Size: Type = 47;
    pub const Start: Type = 48;
    pub const Store: Type = 49;
    pub const Sub: Type = 50;
    pub const Switch: Type = 51;
    pub const Sync: Type = 52;
    pub const Tuple: Type = 53;
    pub const Unknown: Type = 54;
    pub const First: Type = 0;
    pub const Last: Type = 54;
}
pub mod n_ASM {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Max: Type = 0;
}
pub mod pn_ASM {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const FirstOut: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn is_ASM(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_ASM_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_ASM_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_ASM_n_inputs(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_ASM_input(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_ASM_input(node: *mut ir_node, pos: ::std::os::raw::c_int, input: *mut ir_node);
}
extern "C" {
    pub fn get_ASM_input_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    pub fn get_ASM_constraints(node: *const ir_node) -> *mut ir_asm_constraint;
}
extern "C" {
    pub fn set_ASM_constraints(node: *mut ir_node, constraints: *mut ir_asm_constraint);
}
extern "C" {
    pub fn get_ASM_clobbers(node: *const ir_node) -> *mut *mut ident;
}
extern "C" {
    pub fn set_ASM_clobbers(node: *mut ir_node, clobbers: *mut *mut ident);
}
extern "C" {
    pub fn get_ASM_text(node: *const ir_node) -> *mut ident;
}
extern "C" {
    pub fn set_ASM_text(node: *mut ir_node, text: *mut ident);
}
extern "C" {
    #[link_name = "\u{1}op_ASM"]
    pub static mut op_ASM: *mut ir_op;
}
extern "C" {
    pub fn get_op_ASM() -> *mut ir_op;
}
pub mod n_Add {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Add(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Add(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Add(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Add(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Add(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Add_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Add_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Add_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Add_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Add"]
    pub static mut op_Add: *mut ir_op;
}
extern "C" {
    pub fn get_op_Add() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Address(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Address(irg: *mut ir_graph, entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Address(dbgi: *mut dbg_info, entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    pub fn new_Address(entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    pub fn is_Address(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Address_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    pub fn set_Address_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    #[link_name = "\u{1}op_Address"]
    pub static mut op_Address: *mut ir_op;
}
extern "C" {
    pub fn get_op_Address() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Align(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Align(irg: *mut ir_graph, mode: *mut ir_mode, type_: *mut ir_type)
        -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Align(
        dbgi: *mut dbg_info,
        mode: *mut ir_mode,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Align(mode: *mut ir_mode, type_: *mut ir_type) -> *mut ir_node;
}
extern "C" {
    pub fn is_Align(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Align_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn set_Align_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[link_name = "\u{1}op_Align"]
    pub static mut op_Align: *mut ir_op;
}
extern "C" {
    pub fn get_op_Align() -> *mut ir_op;
}
pub mod n_Alloc {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Size: Type = 1;
    pub const Max: Type = 1;
}
pub mod pn_Alloc {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const Res: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Alloc(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_size: *mut ir_node,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Alloc(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_size: *mut ir_node,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Alloc(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_size: *mut ir_node,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Alloc(
        irn_mem: *mut ir_node,
        irn_size: *mut ir_node,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Alloc(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Alloc_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Alloc_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Alloc_size(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Alloc_size(node: *mut ir_node, size: *mut ir_node);
}
extern "C" {
    pub fn get_Alloc_alignment(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_Alloc_alignment(node: *mut ir_node, alignment: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}op_Alloc"]
    pub static mut op_Alloc: *mut ir_op;
}
extern "C" {
    pub fn get_op_Alloc() -> *mut ir_op;
}
pub mod n_Anchor {
    pub type Type = u32;
    pub const EndBlock: Type = 0;
    pub const StartBlock: Type = 1;
    pub const End: Type = 2;
    pub const Start: Type = 3;
    pub const Frame: Type = 4;
    pub const InitialMem: Type = 5;
    pub const Args: Type = 6;
    pub const NoMem: Type = 7;
    pub const Max: Type = 7;
}
extern "C" {
    pub fn is_Anchor(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Anchor_end_block(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Anchor_end_block(node: *mut ir_node, end_block: *mut ir_node);
}
extern "C" {
    pub fn get_Anchor_start_block(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Anchor_start_block(node: *mut ir_node, start_block: *mut ir_node);
}
extern "C" {
    pub fn get_Anchor_end(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Anchor_end(node: *mut ir_node, end: *mut ir_node);
}
extern "C" {
    pub fn get_Anchor_start(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Anchor_start(node: *mut ir_node, start: *mut ir_node);
}
extern "C" {
    pub fn get_Anchor_frame(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Anchor_frame(node: *mut ir_node, frame: *mut ir_node);
}
extern "C" {
    pub fn get_Anchor_initial_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Anchor_initial_mem(node: *mut ir_node, initial_mem: *mut ir_node);
}
extern "C" {
    pub fn get_Anchor_args(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Anchor_args(node: *mut ir_node, args: *mut ir_node);
}
extern "C" {
    pub fn get_Anchor_no_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Anchor_no_mem(node: *mut ir_node, no_mem: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Anchor"]
    pub static mut op_Anchor: *mut ir_op;
}
extern "C" {
    pub fn get_op_Anchor() -> *mut ir_op;
}
pub mod n_And {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_And(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_And(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_And(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_And(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_And(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_And_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_And_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_And_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_And_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_And"]
    pub static mut op_And: *mut ir_op;
}
extern "C" {
    pub fn get_op_And() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Bad(dbgi: *mut dbg_info, irg: *mut ir_graph, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Bad(irg: *mut ir_graph, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Bad(dbgi: *mut dbg_info, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn new_Bad(mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn is_Bad(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}op_Bad"]
    pub static mut op_Bad: *mut ir_op;
}
extern "C" {
    pub fn get_op_Bad() -> *mut ir_op;
}
pub mod n_Bitcast {
    pub type Type = u32;
    pub const Op: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Bitcast(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Bitcast(
        block: *mut ir_node,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Bitcast(
        dbgi: *mut dbg_info,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Bitcast(irn_op: *mut ir_node, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn is_Bitcast(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Bitcast_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Bitcast_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Bitcast"]
    pub static mut op_Bitcast: *mut ir_op;
}
extern "C" {
    pub fn get_op_Bitcast() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Block(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Block(
        irg: *mut ir_graph,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Block(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Block(arity: ::std::os::raw::c_int, in_: *const *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Block(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Block_n_cfgpreds(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Block_cfgpred(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_Block_cfgpred(node: *mut ir_node, pos: ::std::os::raw::c_int, cfgpred: *mut ir_node);
}
extern "C" {
    pub fn get_Block_cfgpred_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    pub fn get_Block_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    pub fn set_Block_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    #[link_name = "\u{1}op_Block"]
    pub static mut op_Block: *mut ir_op;
}
extern "C" {
    pub fn get_op_Block() -> *mut ir_op;
}
pub mod n_Builtin {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Max: Type = 0;
}
pub mod pn_Builtin {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Builtin(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        kind: ir_builtin_kind::Type,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Builtin(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        kind: ir_builtin_kind::Type,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Builtin(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        kind: ir_builtin_kind::Type,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Builtin(
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        kind: ir_builtin_kind::Type,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Builtin(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Builtin_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Builtin_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Builtin_n_params(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Builtin_param(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_Builtin_param(node: *mut ir_node, pos: ::std::os::raw::c_int, param: *mut ir_node);
}
extern "C" {
    pub fn get_Builtin_param_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    pub fn get_Builtin_kind(node: *const ir_node) -> ir_builtin_kind::Type;
}
extern "C" {
    pub fn set_Builtin_kind(node: *mut ir_node, kind: ir_builtin_kind::Type);
}
extern "C" {
    pub fn get_Builtin_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn set_Builtin_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[link_name = "\u{1}op_Builtin"]
    pub static mut op_Builtin: *mut ir_op;
}
extern "C" {
    pub fn get_op_Builtin() -> *mut ir_op;
}
pub mod n_Call {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Ptr: Type = 1;
    pub const Max: Type = 1;
}
pub mod pn_Call {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const TResult: Type = 1;
    pub const XRegular: Type = 2;
    pub const XExcept: Type = 3;
    pub const Max: Type = 3;
}
extern "C" {
    pub fn new_rd_Call(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Call(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Call(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Call(
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Call(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Call_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Call_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Call_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Call_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    pub fn get_Call_n_params(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Call_param(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_Call_param(node: *mut ir_node, pos: ::std::os::raw::c_int, param: *mut ir_node);
}
extern "C" {
    pub fn get_Call_param_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    pub fn get_Call_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn set_Call_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[link_name = "\u{1}op_Call"]
    pub static mut op_Call: *mut ir_op;
}
extern "C" {
    pub fn get_op_Call() -> *mut ir_op;
}
pub mod n_Cmp {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Cmp(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        relation: ir_relation::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Cmp(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        relation: ir_relation::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Cmp(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        relation: ir_relation::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Cmp(
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        relation: ir_relation::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Cmp(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Cmp_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Cmp_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Cmp_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Cmp_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    pub fn get_Cmp_relation(node: *const ir_node) -> ir_relation::Type;
}
extern "C" {
    pub fn set_Cmp_relation(node: *mut ir_node, relation: ir_relation::Type);
}
extern "C" {
    #[link_name = "\u{1}op_Cmp"]
    pub static mut op_Cmp: *mut ir_op;
}
extern "C" {
    pub fn get_op_Cmp() -> *mut ir_op;
}
pub mod n_Cond {
    pub type Type = u32;
    pub const Selector: Type = 0;
    pub const Max: Type = 0;
}
pub mod pn_Cond {
    pub type Type = u32;
    pub const False: Type = 0;
    pub const True: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Cond(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_selector: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Cond(block: *mut ir_node, irn_selector: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Cond(dbgi: *mut dbg_info, irn_selector: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_Cond(irn_selector: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Cond(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Cond_selector(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Cond_selector(node: *mut ir_node, selector: *mut ir_node);
}
extern "C" {
    pub fn get_Cond_jmp_pred(node: *const ir_node) -> cond_jmp_predicate::Type;
}
extern "C" {
    pub fn set_Cond_jmp_pred(node: *mut ir_node, jmp_pred: cond_jmp_predicate::Type);
}
extern "C" {
    #[link_name = "\u{1}op_Cond"]
    pub static mut op_Cond: *mut ir_op;
}
extern "C" {
    pub fn get_op_Cond() -> *mut ir_op;
}
pub mod n_Confirm {
    pub type Type = u32;
    pub const Value: Type = 0;
    pub const Bound: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Confirm(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_value: *mut ir_node,
        irn_bound: *mut ir_node,
        relation: ir_relation::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Confirm(
        block: *mut ir_node,
        irn_value: *mut ir_node,
        irn_bound: *mut ir_node,
        relation: ir_relation::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Confirm(
        dbgi: *mut dbg_info,
        irn_value: *mut ir_node,
        irn_bound: *mut ir_node,
        relation: ir_relation::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Confirm(
        irn_value: *mut ir_node,
        irn_bound: *mut ir_node,
        relation: ir_relation::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Confirm(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Confirm_value(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Confirm_value(node: *mut ir_node, value: *mut ir_node);
}
extern "C" {
    pub fn get_Confirm_bound(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Confirm_bound(node: *mut ir_node, bound: *mut ir_node);
}
extern "C" {
    pub fn get_Confirm_relation(node: *const ir_node) -> ir_relation::Type;
}
extern "C" {
    pub fn set_Confirm_relation(node: *mut ir_node, relation: ir_relation::Type);
}
extern "C" {
    #[link_name = "\u{1}op_Confirm"]
    pub static mut op_Confirm: *mut ir_op;
}
extern "C" {
    pub fn get_op_Confirm() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Const(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        tarval: *mut ir_tarval,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Const(irg: *mut ir_graph, tarval: *mut ir_tarval) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Const(dbgi: *mut dbg_info, tarval: *mut ir_tarval) -> *mut ir_node;
}
extern "C" {
    pub fn new_Const(tarval: *mut ir_tarval) -> *mut ir_node;
}
extern "C" {
    pub fn is_Const(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Const_tarval(node: *const ir_node) -> *mut ir_tarval;
}
extern "C" {
    pub fn set_Const_tarval(node: *mut ir_node, tarval: *mut ir_tarval);
}
extern "C" {
    #[link_name = "\u{1}op_Const"]
    pub static mut op_Const: *mut ir_op;
}
extern "C" {
    pub fn get_op_Const() -> *mut ir_op;
}
pub mod n_Conv {
    pub type Type = u32;
    pub const Op: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Conv(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Conv(
        block: *mut ir_node,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Conv(
        dbgi: *mut dbg_info,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Conv(irn_op: *mut ir_node, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn is_Conv(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Conv_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Conv_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Conv"]
    pub static mut op_Conv: *mut ir_op;
}
extern "C" {
    pub fn get_op_Conv() -> *mut ir_op;
}
pub mod n_CopyB {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Dst: Type = 1;
    pub const Src: Type = 2;
    pub const Max: Type = 2;
}
extern "C" {
    pub fn new_rd_CopyB(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_dst: *mut ir_node,
        irn_src: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_CopyB(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_dst: *mut ir_node,
        irn_src: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_CopyB(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_dst: *mut ir_node,
        irn_src: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_CopyB(
        irn_mem: *mut ir_node,
        irn_dst: *mut ir_node,
        irn_src: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_CopyB(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_CopyB_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_CopyB_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_CopyB_dst(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_CopyB_dst(node: *mut ir_node, dst: *mut ir_node);
}
extern "C" {
    pub fn get_CopyB_src(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_CopyB_src(node: *mut ir_node, src: *mut ir_node);
}
extern "C" {
    pub fn get_CopyB_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn set_CopyB_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    pub fn get_CopyB_volatility(node: *const ir_node) -> ir_volatility::Type;
}
extern "C" {
    pub fn set_CopyB_volatility(node: *mut ir_node, volatility: ir_volatility::Type);
}
extern "C" {
    #[link_name = "\u{1}op_CopyB"]
    pub static mut op_CopyB: *mut ir_op;
}
extern "C" {
    pub fn get_op_CopyB() -> *mut ir_op;
}
extern "C" {
    pub fn is_Deleted(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}op_Deleted"]
    pub static mut op_Deleted: *mut ir_op;
}
extern "C" {
    pub fn get_op_Deleted() -> *mut ir_op;
}
pub mod n_Div {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Left: Type = 1;
    pub const Right: Type = 2;
    pub const Max: Type = 2;
}
pub mod pn_Div {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const Res: Type = 1;
    pub const XRegular: Type = 2;
    pub const XExcept: Type = 3;
    pub const Max: Type = 3;
}
extern "C" {
    pub fn new_rd_Div(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Div(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Div(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Div(
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Div(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Div_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Div_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Div_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Div_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Div_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Div_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    pub fn get_Div_resmode(node: *const ir_node) -> *mut ir_mode;
}
extern "C" {
    pub fn set_Div_resmode(node: *mut ir_node, resmode: *mut ir_mode);
}
extern "C" {
    pub fn get_Div_no_remainder(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_Div_no_remainder(node: *mut ir_node, no_remainder: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}op_Div"]
    pub static mut op_Div: *mut ir_op;
}
extern "C" {
    pub fn get_op_Div() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Dummy(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Dummy(irg: *mut ir_graph, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Dummy(dbgi: *mut dbg_info, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn new_Dummy(mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn is_Dummy(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}op_Dummy"]
    pub static mut op_Dummy: *mut ir_op;
}
extern "C" {
    pub fn get_op_Dummy() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_End(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_End(
        irg: *mut ir_graph,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_End(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_End(arity: ::std::os::raw::c_int, in_: *const *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_End(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_End_n_keepalives(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_End_keepalive(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_End_keepalive(
        node: *mut ir_node,
        pos: ::std::os::raw::c_int,
        keepalive: *mut ir_node,
    );
}
extern "C" {
    pub fn get_End_keepalive_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[link_name = "\u{1}op_End"]
    pub static mut op_End: *mut ir_op;
}
extern "C" {
    pub fn get_op_End() -> *mut ir_op;
}
pub mod n_Eor {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Eor(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Eor(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Eor(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Eor(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Eor(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Eor_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Eor_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Eor_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Eor_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Eor"]
    pub static mut op_Eor: *mut ir_op;
}
extern "C" {
    pub fn get_op_Eor() -> *mut ir_op;
}
pub mod n_Free {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Ptr: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Free(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Free(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Free(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Free(irn_mem: *mut ir_node, irn_ptr: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Free(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Free_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Free_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Free_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Free_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Free"]
    pub static mut op_Free: *mut ir_op;
}
extern "C" {
    pub fn get_op_Free() -> *mut ir_op;
}
pub mod n_IJmp {
    pub type Type = u32;
    pub const Target: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_IJmp(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_target: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_IJmp(block: *mut ir_node, irn_target: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_IJmp(dbgi: *mut dbg_info, irn_target: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_IJmp(irn_target: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_IJmp(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_IJmp_target(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_IJmp_target(node: *mut ir_node, target: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_IJmp"]
    pub static mut op_IJmp: *mut ir_op;
}
extern "C" {
    pub fn get_op_IJmp() -> *mut ir_op;
}
pub mod n_Id {
    pub type Type = u32;
    pub const Pred: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn is_Id(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Id_pred(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Id_pred(node: *mut ir_node, pred: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Id"]
    pub static mut op_Id: *mut ir_op;
}
extern "C" {
    pub fn get_op_Id() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Jmp(dbgi: *mut dbg_info, block: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Jmp(block: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Jmp(dbgi: *mut dbg_info) -> *mut ir_node;
}
extern "C" {
    pub fn new_Jmp() -> *mut ir_node;
}
extern "C" {
    pub fn is_Jmp(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}op_Jmp"]
    pub static mut op_Jmp: *mut ir_op;
}
extern "C" {
    pub fn get_op_Jmp() -> *mut ir_op;
}
pub mod n_Load {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Ptr: Type = 1;
    pub const Max: Type = 1;
}
pub mod pn_Load {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const Res: Type = 1;
    pub const XRegular: Type = 2;
    pub const XExcept: Type = 3;
    pub const Max: Type = 3;
}
extern "C" {
    pub fn new_rd_Load(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        mode: *mut ir_mode,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Load(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        mode: *mut ir_mode,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Load(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        mode: *mut ir_mode,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Load(
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        mode: *mut ir_mode,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Load(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Load_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Load_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Load_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Load_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    pub fn get_Load_mode(node: *const ir_node) -> *mut ir_mode;
}
extern "C" {
    pub fn set_Load_mode(node: *mut ir_node, mode: *mut ir_mode);
}
extern "C" {
    pub fn get_Load_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn set_Load_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    pub fn get_Load_volatility(node: *const ir_node) -> ir_volatility::Type;
}
extern "C" {
    pub fn set_Load_volatility(node: *mut ir_node, volatility: ir_volatility::Type);
}
extern "C" {
    pub fn get_Load_unaligned(node: *const ir_node) -> ir_align::Type;
}
extern "C" {
    pub fn set_Load_unaligned(node: *mut ir_node, unaligned: ir_align::Type);
}
extern "C" {
    #[link_name = "\u{1}op_Load"]
    pub static mut op_Load: *mut ir_op;
}
extern "C" {
    pub fn get_op_Load() -> *mut ir_op;
}
pub mod n_Member {
    pub type Type = u32;
    pub const Ptr: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Member(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_ptr: *mut ir_node,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Member(
        block: *mut ir_node,
        irn_ptr: *mut ir_node,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Member(
        dbgi: *mut dbg_info,
        irn_ptr: *mut ir_node,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Member(irn_ptr: *mut ir_node, entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    pub fn is_Member(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Member_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Member_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    pub fn get_Member_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    pub fn set_Member_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    #[link_name = "\u{1}op_Member"]
    pub static mut op_Member: *mut ir_op;
}
extern "C" {
    pub fn get_op_Member() -> *mut ir_op;
}
pub mod n_Minus {
    pub type Type = u32;
    pub const Op: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Minus(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Minus(block: *mut ir_node, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Minus(dbgi: *mut dbg_info, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_Minus(irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Minus(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Minus_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Minus_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Minus"]
    pub static mut op_Minus: *mut ir_op;
}
extern "C" {
    pub fn get_op_Minus() -> *mut ir_op;
}
pub mod n_Mod {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Left: Type = 1;
    pub const Right: Type = 2;
    pub const Max: Type = 2;
}
pub mod pn_Mod {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const Res: Type = 1;
    pub const XRegular: Type = 2;
    pub const XExcept: Type = 3;
    pub const Max: Type = 3;
}
extern "C" {
    pub fn new_rd_Mod(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Mod(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Mod(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Mod(
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Mod(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Mod_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mod_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Mod_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mod_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Mod_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mod_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    pub fn get_Mod_resmode(node: *const ir_node) -> *mut ir_mode;
}
extern "C" {
    pub fn set_Mod_resmode(node: *mut ir_node, resmode: *mut ir_mode);
}
extern "C" {
    #[link_name = "\u{1}op_Mod"]
    pub static mut op_Mod: *mut ir_op;
}
extern "C" {
    pub fn get_op_Mod() -> *mut ir_op;
}
pub mod n_Mul {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Mul(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Mul(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Mul(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Mul(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Mul(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Mul_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mul_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Mul_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mul_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Mul"]
    pub static mut op_Mul: *mut ir_op;
}
extern "C" {
    pub fn get_op_Mul() -> *mut ir_op;
}
pub mod n_Mulh {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Mulh(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Mulh(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Mulh(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Mulh(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Mulh(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Mulh_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mulh_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Mulh_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mulh_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Mulh"]
    pub static mut op_Mulh: *mut ir_op;
}
extern "C" {
    pub fn get_op_Mulh() -> *mut ir_op;
}
pub mod n_Mux {
    pub type Type = u32;
    pub const Sel: Type = 0;
    pub const False: Type = 1;
    pub const True: Type = 2;
    pub const Max: Type = 2;
}
extern "C" {
    pub fn new_rd_Mux(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_sel: *mut ir_node,
        irn_false: *mut ir_node,
        irn_true: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Mux(
        block: *mut ir_node,
        irn_sel: *mut ir_node,
        irn_false: *mut ir_node,
        irn_true: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Mux(
        dbgi: *mut dbg_info,
        irn_sel: *mut ir_node,
        irn_false: *mut ir_node,
        irn_true: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Mux(
        irn_sel: *mut ir_node,
        irn_false: *mut ir_node,
        irn_true: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Mux(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Mux_sel(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mux_sel(node: *mut ir_node, sel: *mut ir_node);
}
extern "C" {
    pub fn get_Mux_false(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mux_false(node: *mut ir_node, false_: *mut ir_node);
}
extern "C" {
    pub fn get_Mux_true(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Mux_true(node: *mut ir_node, true_: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Mux"]
    pub static mut op_Mux: *mut ir_op;
}
extern "C" {
    pub fn get_op_Mux() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_NoMem(dbgi: *mut dbg_info, irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_NoMem(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_NoMem(dbgi: *mut dbg_info) -> *mut ir_node;
}
extern "C" {
    pub fn new_NoMem() -> *mut ir_node;
}
extern "C" {
    pub fn is_NoMem(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}op_NoMem"]
    pub static mut op_NoMem: *mut ir_op;
}
extern "C" {
    pub fn get_op_NoMem() -> *mut ir_op;
}
pub mod n_Not {
    pub type Type = u32;
    pub const Op: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Not(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Not(block: *mut ir_node, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Not(dbgi: *mut dbg_info, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_Not(irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Not(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Not_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Not_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Not"]
    pub static mut op_Not: *mut ir_op;
}
extern "C" {
    pub fn get_op_Not() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Offset(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Offset(
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Offset(
        dbgi: *mut dbg_info,
        mode: *mut ir_mode,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Offset(mode: *mut ir_mode, entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    pub fn is_Offset(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Offset_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    pub fn set_Offset_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    #[link_name = "\u{1}op_Offset"]
    pub static mut op_Offset: *mut ir_op;
}
extern "C" {
    pub fn get_op_Offset() -> *mut ir_op;
}
pub mod n_Or {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Or(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Or(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Or(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Or(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Or(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Or_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Or_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Or_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Or_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Or"]
    pub static mut op_Or: *mut ir_op;
}
extern "C" {
    pub fn get_op_Or() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Phi(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Phi(
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Phi(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Phi(
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Phi(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Phi_n_preds(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Phi_pred(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_Phi_pred(node: *mut ir_node, pos: ::std::os::raw::c_int, pred: *mut ir_node);
}
extern "C" {
    pub fn get_Phi_pred_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    pub fn get_Phi_loop(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_Phi_loop(node: *mut ir_node, loop_: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}op_Phi"]
    pub static mut op_Phi: *mut ir_op;
}
extern "C" {
    pub fn get_op_Phi() -> *mut ir_op;
}
pub mod n_Pin {
    pub type Type = u32;
    pub const Op: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Pin(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Pin(block: *mut ir_node, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Pin(dbgi: *mut dbg_info, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_Pin(irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Pin(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Pin_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Pin_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Pin"]
    pub static mut op_Pin: *mut ir_op;
}
extern "C" {
    pub fn get_op_Pin() -> *mut ir_op;
}
pub mod n_Proj {
    pub type Type = u32;
    pub const Pred: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Proj(
        dbgi: *mut dbg_info,
        irn_pred: *mut ir_node,
        mode: *mut ir_mode,
        num: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Proj(
        irn_pred: *mut ir_node,
        mode: *mut ir_mode,
        num: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Proj(
        dbgi: *mut dbg_info,
        irn_pred: *mut ir_node,
        mode: *mut ir_mode,
        num: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Proj(
        irn_pred: *mut ir_node,
        mode: *mut ir_mode,
        num: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Proj(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Proj_pred(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Proj_pred(node: *mut ir_node, pred: *mut ir_node);
}
extern "C" {
    pub fn get_Proj_num(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_Proj_num(node: *mut ir_node, num: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}op_Proj"]
    pub static mut op_Proj: *mut ir_op;
}
extern "C" {
    pub fn get_op_Proj() -> *mut ir_op;
}
pub mod n_Raise {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const ExoPtr: Type = 1;
    pub const Max: Type = 1;
}
pub mod pn_Raise {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const X: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Raise(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_exo_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Raise(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_exo_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Raise(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_exo_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Raise(irn_mem: *mut ir_node, irn_exo_ptr: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Raise(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Raise_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Raise_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Raise_exo_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Raise_exo_ptr(node: *mut ir_node, exo_ptr: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Raise"]
    pub static mut op_Raise: *mut ir_op;
}
extern "C" {
    pub fn get_op_Raise() -> *mut ir_op;
}
pub mod n_Return {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Return(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Return(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Return(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Return(
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Return(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Return_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Return_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Return_n_ress(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Return_res(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_Return_res(node: *mut ir_node, pos: ::std::os::raw::c_int, res: *mut ir_node);
}
extern "C" {
    pub fn get_Return_res_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[link_name = "\u{1}op_Return"]
    pub static mut op_Return: *mut ir_op;
}
extern "C" {
    pub fn get_op_Return() -> *mut ir_op;
}
pub mod n_Sel {
    pub type Type = u32;
    pub const Ptr: Type = 0;
    pub const Index: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Sel(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_index: *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Sel(
        block: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_index: *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Sel(
        dbgi: *mut dbg_info,
        irn_ptr: *mut ir_node,
        irn_index: *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Sel(
        irn_ptr: *mut ir_node,
        irn_index: *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Sel(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Sel_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Sel_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    pub fn get_Sel_index(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Sel_index(node: *mut ir_node, index: *mut ir_node);
}
extern "C" {
    pub fn get_Sel_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn set_Sel_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[link_name = "\u{1}op_Sel"]
    pub static mut op_Sel: *mut ir_op;
}
extern "C" {
    pub fn get_op_Sel() -> *mut ir_op;
}
pub mod n_Shl {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Shl(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Shl(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Shl(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Shl(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Shl(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Shl_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Shl_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Shl_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Shl_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Shl"]
    pub static mut op_Shl: *mut ir_op;
}
extern "C" {
    pub fn get_op_Shl() -> *mut ir_op;
}
pub mod n_Shr {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Shr(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Shr(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Shr(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Shr(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Shr(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Shr_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Shr_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Shr_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Shr_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Shr"]
    pub static mut op_Shr: *mut ir_op;
}
extern "C" {
    pub fn get_op_Shr() -> *mut ir_op;
}
pub mod n_Shrs {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Shrs(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Shrs(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Shrs(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Shrs(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Shrs(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Shrs_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Shrs_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Shrs_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Shrs_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Shrs"]
    pub static mut op_Shrs: *mut ir_op;
}
extern "C" {
    pub fn get_op_Shrs() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Size(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Size(irg: *mut ir_graph, mode: *mut ir_mode, type_: *mut ir_type) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Size(dbgi: *mut dbg_info, mode: *mut ir_mode, type_: *mut ir_type)
        -> *mut ir_node;
}
extern "C" {
    pub fn new_Size(mode: *mut ir_mode, type_: *mut ir_type) -> *mut ir_node;
}
extern "C" {
    pub fn is_Size(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Size_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn set_Size_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[link_name = "\u{1}op_Size"]
    pub static mut op_Size: *mut ir_op;
}
extern "C" {
    pub fn get_op_Size() -> *mut ir_op;
}
pub mod pn_Start {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const PFrameBase: Type = 1;
    pub const TArgs: Type = 2;
    pub const Max: Type = 2;
}
extern "C" {
    pub fn new_rd_Start(dbgi: *mut dbg_info, irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Start(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Start(dbgi: *mut dbg_info) -> *mut ir_node;
}
extern "C" {
    pub fn new_Start() -> *mut ir_node;
}
extern "C" {
    pub fn is_Start(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}op_Start"]
    pub static mut op_Start: *mut ir_op;
}
extern "C" {
    pub fn get_op_Start() -> *mut ir_op;
}
pub mod n_Store {
    pub type Type = u32;
    pub const Mem: Type = 0;
    pub const Ptr: Type = 1;
    pub const Value: Type = 2;
    pub const Max: Type = 2;
}
pub mod pn_Store {
    pub type Type = u32;
    pub const M: Type = 0;
    pub const XRegular: Type = 1;
    pub const XExcept: Type = 2;
    pub const Max: Type = 2;
}
extern "C" {
    pub fn new_rd_Store(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_value: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Store(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_value: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Store(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_value: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Store(
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_value: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags::Type,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Store(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Store_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Store_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn get_Store_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Store_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    pub fn get_Store_value(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Store_value(node: *mut ir_node, value: *mut ir_node);
}
extern "C" {
    pub fn get_Store_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn set_Store_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    pub fn get_Store_volatility(node: *const ir_node) -> ir_volatility::Type;
}
extern "C" {
    pub fn set_Store_volatility(node: *mut ir_node, volatility: ir_volatility::Type);
}
extern "C" {
    pub fn get_Store_unaligned(node: *const ir_node) -> ir_align::Type;
}
extern "C" {
    pub fn set_Store_unaligned(node: *mut ir_node, unaligned: ir_align::Type);
}
extern "C" {
    #[link_name = "\u{1}op_Store"]
    pub static mut op_Store: *mut ir_op;
}
extern "C" {
    pub fn get_op_Store() -> *mut ir_op;
}
pub mod n_Sub {
    pub type Type = u32;
    pub const Left: Type = 0;
    pub const Right: Type = 1;
    pub const Max: Type = 1;
}
extern "C" {
    pub fn new_rd_Sub(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Sub(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Sub(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Sub(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Sub(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Sub_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Sub_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_Sub_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Sub_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[link_name = "\u{1}op_Sub"]
    pub static mut op_Sub: *mut ir_op;
}
extern "C" {
    pub fn get_op_Sub() -> *mut ir_op;
}
pub mod n_Switch {
    pub type Type = u32;
    pub const Selector: Type = 0;
    pub const Max: Type = 0;
}
pub mod pn_Switch {
    pub type Type = u32;
    pub const Default: Type = 0;
    pub const Max: Type = 0;
}
extern "C" {
    pub fn new_rd_Switch(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_selector: *mut ir_node,
        n_outs: ::std::os::raw::c_uint,
        table: *mut ir_switch_table,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Switch(
        block: *mut ir_node,
        irn_selector: *mut ir_node,
        n_outs: ::std::os::raw::c_uint,
        table: *mut ir_switch_table,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Switch(
        dbgi: *mut dbg_info,
        irn_selector: *mut ir_node,
        n_outs: ::std::os::raw::c_uint,
        table: *mut ir_switch_table,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Switch(
        irn_selector: *mut ir_node,
        n_outs: ::std::os::raw::c_uint,
        table: *mut ir_switch_table,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn is_Switch(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Switch_selector(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Switch_selector(node: *mut ir_node, selector: *mut ir_node);
}
extern "C" {
    pub fn get_Switch_n_outs(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_Switch_n_outs(node: *mut ir_node, n_outs: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn get_Switch_table(node: *const ir_node) -> *mut ir_switch_table;
}
extern "C" {
    pub fn set_Switch_table(node: *mut ir_node, table: *mut ir_switch_table);
}
extern "C" {
    #[link_name = "\u{1}op_Switch"]
    pub static mut op_Switch: *mut ir_op;
}
extern "C" {
    pub fn get_op_Switch() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Sync(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Sync(
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Sync(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Sync(arity: ::std::os::raw::c_int, in_: *const *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Sync(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Sync_n_preds(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Sync_pred(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_Sync_pred(node: *mut ir_node, pos: ::std::os::raw::c_int, pred: *mut ir_node);
}
extern "C" {
    pub fn get_Sync_pred_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[link_name = "\u{1}op_Sync"]
    pub static mut op_Sync: *mut ir_op;
}
extern "C" {
    pub fn get_op_Sync() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Tuple(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Tuple(
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Tuple(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Tuple(arity: ::std::os::raw::c_int, in_: *const *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_Tuple(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Tuple_n_preds(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Tuple_pred(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_Tuple_pred(node: *mut ir_node, pos: ::std::os::raw::c_int, pred: *mut ir_node);
}
extern "C" {
    pub fn get_Tuple_pred_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[link_name = "\u{1}op_Tuple"]
    pub static mut op_Tuple: *mut ir_op;
}
extern "C" {
    pub fn get_op_Tuple() -> *mut ir_op;
}
extern "C" {
    pub fn new_rd_Unknown(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Unknown(irg: *mut ir_graph, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Unknown(dbgi: *mut dbg_info, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn new_Unknown(mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn is_Unknown(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}op_Unknown"]
    pub static mut op_Unknown: *mut ir_op;
}
extern "C" {
    pub fn get_op_Unknown() -> *mut ir_op;
}
extern "C" {
    pub fn is_binop(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_entconst(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_entconst_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    pub fn set_entconst_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    pub fn is_typeconst(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_typeconst_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn set_typeconst_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    pub fn get_irn_arity(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_irn_n(node: *const ir_node, n: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    pub fn set_irn_in(node: *mut ir_node, arity: ::std::os::raw::c_int, in_: *const *mut ir_node);
}
extern "C" {
    pub fn set_irn_n(node: *mut ir_node, n: ::std::os::raw::c_int, in_: *mut ir_node);
}
extern "C" {
    pub fn add_irn_n(node: *mut ir_node, in_: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_irn_mode(node: *mut ir_node, mode: *mut ir_mode);
}
extern "C" {
    pub fn get_irn_mode(node: *const ir_node) -> *mut ir_mode;
}
extern "C" {
    pub fn get_irn_op(node: *const ir_node) -> *mut ir_op;
}
extern "C" {
    pub fn get_irn_opcode(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_irn_opname(node: *const ir_node) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_irn_opident(node: *const ir_node) -> *mut ident;
}
extern "C" {
    pub fn get_irn_visited(node: *const ir_node) -> ir_visited_t;
}
extern "C" {
    pub fn set_irn_visited(node: *mut ir_node, visited: ir_visited_t);
}
extern "C" {
    pub fn mark_irn_visited(node: *mut ir_node);
}
extern "C" {
    pub fn irn_visited(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn irn_visited_else_mark(node: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_irn_link(node: *mut ir_node, link: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn get_irn_link(node: *const ir_node) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_irn_irg(node: *const ir_node) -> *mut ir_graph;
}
extern "C" {
    pub fn get_irn_node_nr(node: *const ir_node) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn get_irn_pinned(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_irn_pinned(node: *mut ir_node, pinned: ::std::os::raw::c_int);
}
extern "C" {
    pub fn new_ir_node(
        db: *mut dbg_info,
        irg: *mut ir_graph,
        block: *mut ir_node,
        op: *mut ir_op,
        mode: *mut ir_mode,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn get_nodes_block(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_nodes_block(node: *mut ir_node, block: *mut ir_node);
}
extern "C" {
    pub fn get_Block_cfgpred_block(
        node: *const ir_node,
        pos: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn get_Block_matured(block: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_Block_matured(block: *mut ir_node, matured: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_Block_block_visited(block: *const ir_node) -> ir_visited_t;
}
extern "C" {
    pub fn set_Block_block_visited(block: *mut ir_node, visit: ir_visited_t);
}
extern "C" {
    pub fn mark_Block_block_visited(node: *mut ir_node);
}
extern "C" {
    pub fn Block_block_visited(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn create_Block_entity(block: *mut ir_node) -> *mut ir_entity;
}
extern "C" {
    pub fn get_Block_phis(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Block_phis(block: *mut ir_node, phi: *mut ir_node);
}
extern "C" {
    pub fn add_Block_phi(block: *mut ir_node, phi: *mut ir_node);
}
extern "C" {
    pub fn get_Block_mark(block: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_Block_mark(block: *mut ir_node, mark: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn add_End_keepalive(end: *mut ir_node, ka: *mut ir_node);
}
extern "C" {
    pub fn set_End_keepalives(end: *mut ir_node, n: ::std::os::raw::c_int, in_: *mut *mut ir_node);
}
extern "C" {
    pub fn remove_End_keepalive(end: *mut ir_node, irn: *const ir_node);
}
extern "C" {
    pub fn remove_End_n(end: *mut ir_node, idx: ::std::os::raw::c_int);
}
extern "C" {
    pub fn remove_End_Bads_and_doublets(end: *mut ir_node);
}
extern "C" {
    pub fn free_End(end: *mut ir_node);
}
extern "C" {
    pub fn is_Const_null(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_Const_one(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_Const_all_one(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Call_callee(call: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    pub fn get_builtin_kind_name(kind: ir_builtin_kind::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_binop_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_binop_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    pub fn get_binop_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_binop_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    pub fn is_x_except_Proj(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_x_regular_Proj(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_set_throws_exception(node: *mut ir_node, throws_exception: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ir_throws_exception(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_relation_string(relation: ir_relation::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_negated_relation(relation: ir_relation::Type) -> ir_relation::Type;
}
extern "C" {
    pub fn get_inversed_relation(relation: ir_relation::Type) -> ir_relation::Type;
}
extern "C" {
    pub fn get_Phi_next(phi: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_Phi_next(phi: *mut ir_node, next: *mut ir_node);
}
extern "C" {
    pub fn is_memop(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_memop_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn set_memop_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    pub fn add_Sync_pred(node: *mut ir_node, pred: *mut ir_node);
}
extern "C" {
    pub fn remove_Sync_n(n: *mut ir_node, i: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_ASM_n_constraints(node: *const ir_node) -> usize;
}
extern "C" {
    pub fn get_ASM_n_clobbers(node: *const ir_node) -> usize;
}
extern "C" {
    pub fn skip_Proj(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn skip_Proj_const(node: *const ir_node) -> *const ir_node;
}
extern "C" {
    pub fn skip_Id(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn skip_Tuple(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn skip_Pin(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn skip_Confirm(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn is_cfop(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_unknown_jump(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_fragile_op(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_irn_forking(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_irn_const_memory(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copy_node_attr(irg: *mut ir_graph, old_node: *const ir_node, new_node: *mut ir_node);
}
extern "C" {
    pub fn get_irn_type_attr(n: *mut ir_node) -> *mut ir_type;
}
extern "C" {
    pub fn get_irn_entity_attr(n: *mut ir_node) -> *mut ir_entity;
}
extern "C" {
    pub fn is_irn_constlike(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_irn_keep(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_irn_start_block_placed(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_cond_jmp_predicate_name(
        pred: cond_jmp_predicate::Type,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_irn_generic_attr(node: *mut ir_node) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_irn_generic_attr_const(node: *const ir_node) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_irn_idx(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_irn_dbg_info(n: *mut ir_node, db: *mut dbg_info);
}
extern "C" {
    pub fn get_irn_dbg_info(n: *const ir_node) -> *mut dbg_info;
}
extern "C" {
    pub fn gdb_node_helper(
        firm_object: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_new_switch_table(irg: *mut ir_graph, n_entries: usize) -> *mut ir_switch_table;
}
extern "C" {
    pub fn ir_switch_table_get_n_entries(table: *const ir_switch_table) -> usize;
}
extern "C" {
    pub fn ir_switch_table_set(
        table: *mut ir_switch_table,
        entry: usize,
        min: *mut ir_tarval,
        max: *mut ir_tarval,
        pn: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn ir_switch_table_get_max(table: *const ir_switch_table, entry: usize) -> *mut ir_tarval;
}
extern "C" {
    pub fn ir_switch_table_get_min(table: *const ir_switch_table, entry: usize) -> *mut ir_tarval;
}
extern "C" {
    pub fn ir_switch_table_get_pn(
        table: *const ir_switch_table,
        entry: usize,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_switch_table_duplicate(
        irg: *mut ir_graph,
        table: *const ir_switch_table,
    ) -> *mut ir_switch_table;
}
extern "C" {
    pub fn new_rd_Const_long(
        db: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        value: ::std::os::raw::c_long,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Const_long(
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        value: ::std::os::raw::c_long,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Const_long(
        db: *mut dbg_info,
        mode: *mut ir_mode,
        value: ::std::os::raw::c_long,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Const_long(mode: *mut ir_mode, value: ::std::os::raw::c_long) -> *mut ir_node;
}
extern "C" {
    pub fn new_rd_Phi_loop(
        db: *mut dbg_info,
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_Phi_loop(
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_Phi_loop(
        db: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_Phi_loop(arity: ::std::os::raw::c_int, in_: *mut *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn new_rd_DivRL(
        db: *mut dbg_info,
        block: *mut ir_node,
        memop: *mut ir_node,
        op1: *mut ir_node,
        op2: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_DivRL(
        block: *mut ir_node,
        memop: *mut ir_node,
        op1: *mut ir_node,
        op2: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_DivRL(
        db: *mut dbg_info,
        memop: *mut ir_node,
        op1: *mut ir_node,
        op2: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_DivRL(
        memop: *mut ir_node,
        op1: *mut ir_node,
        op2: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_rd_ASM(
        db: *mut dbg_info,
        block: *mut ir_node,
        mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
        n_constraints: usize,
        constraints: *mut ir_asm_constraint,
        n_clobber: usize,
        clobber: *mut *mut ident,
        asm_text: *mut ident,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_r_ASM(
        block: *mut ir_node,
        mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
        n_constraints: usize,
        constraints: *mut ir_asm_constraint,
        n_clobber: usize,
        clobber: *mut *mut ident,
        asm_text: *mut ident,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_d_ASM(
        db: *mut dbg_info,
        mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
        n_constraints: usize,
        constraints: *mut ir_asm_constraint,
        n_clobber: usize,
        clobber: *mut *mut ident,
        asm_text: *mut ident,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn new_ASM(
        mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
        n_constraints: usize,
        constraints: *mut ir_asm_constraint,
        n_clobber: usize,
        clobber: *mut *mut ident,
        asm_text: *mut ident,
    ) -> *mut ir_node;
}
extern "C" {
    #[link_name = "\u{1}current_ir_graph"]
    pub static mut current_ir_graph: *mut ir_graph;
}
extern "C" {
    pub fn get_current_ir_graph() -> *mut ir_graph;
}
extern "C" {
    pub fn set_current_ir_graph(graph: *mut ir_graph);
}
extern "C" {
    pub fn new_d_immBlock(db: *mut dbg_info) -> *mut ir_node;
}
extern "C" {
    pub fn new_immBlock() -> *mut ir_node;
}
extern "C" {
    pub fn new_r_immBlock(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn new_rd_immBlock(db: *mut dbg_info, irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn add_immBlock_pred(immblock: *mut ir_node, jmp: *mut ir_node);
}
extern "C" {
    pub fn mature_immBlock(block: *mut ir_node);
}
extern "C" {
    pub fn set_cur_block(target: *mut ir_node);
}
extern "C" {
    pub fn set_r_cur_block(irg: *mut ir_graph, target: *mut ir_node);
}
extern "C" {
    pub fn get_cur_block() -> *mut ir_node;
}
extern "C" {
    pub fn get_r_cur_block(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn get_value(pos: ::std::os::raw::c_int, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    pub fn get_r_value(
        irg: *mut ir_graph,
        pos: ::std::os::raw::c_int,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn ir_guess_mode(pos: ::std::os::raw::c_int) -> *mut ir_mode;
}
extern "C" {
    pub fn ir_r_guess_mode(irg: *mut ir_graph, pos: ::std::os::raw::c_int) -> *mut ir_mode;
}
extern "C" {
    pub fn set_value(pos: ::std::os::raw::c_int, value: *mut ir_node);
}
extern "C" {
    pub fn set_r_value(irg: *mut ir_graph, pos: ::std::os::raw::c_int, value: *mut ir_node);
}
extern "C" {
    pub fn get_store() -> *mut ir_node;
}
extern "C" {
    pub fn get_r_store(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn set_store(store: *mut ir_node);
}
extern "C" {
    pub fn set_r_store(irg: *mut ir_graph, store: *mut ir_node);
}
extern "C" {
    pub fn keep_alive(ka: *mut ir_node);
}
extern "C" {
    pub fn irg_finalize_cons(irg: *mut ir_graph);
}
extern "C" {
    pub fn verify_new_node(node: *mut ir_node);
}
extern "C" {
    pub fn ir_set_uninitialized_local_variable_func(func: uninitialized_local_variable_func_t);
}
extern "C" {
    pub fn construct_confirms(irg: *mut ir_graph);
}
extern "C" {
    pub fn construct_confirms_only(irg: *mut ir_graph);
}
extern "C" {
    pub fn remove_confirms(irg: *mut ir_graph);
}
extern "C" {
    pub fn get_Block_idom(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn get_Block_ipostdom(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn block_dominates(a: *const ir_node, b: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn block_postdominates(a: *const ir_node, b: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn block_strictly_postdominates(
        a: *const ir_node,
        b: *const ir_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_Block_dominated_first(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn get_Block_postdominated_first(bl: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn get_Block_dominated_next(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn get_Block_postdominated_next(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn ir_deepest_common_dominator(block0: *mut ir_node, block1: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn dom_tree_walk(
        n: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn postdom_tree_walk(
        n: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dom_tree_walk_irg(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn postdom_tree_walk_irg(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn compute_doms(irg: *mut ir_graph);
}
extern "C" {
    pub fn compute_postdoms(irg: *mut ir_graph);
}
extern "C" {
    pub fn ir_compute_dominance_frontiers(irg: *mut ir_graph);
}
extern "C" {
    pub fn ir_get_dominance_frontier(block: *const ir_node) -> *mut *mut ir_node;
}
extern "C" {
    pub fn dump_ir_graph(graph: *mut ir_graph, suffix: *const ::std::os::raw::c_char);
}
pub type ir_prog_dump_func = ::std::option::Option<unsafe extern "C" fn(out: *mut FILE)>;
extern "C" {
    pub fn dump_ir_prog_ext(func: ir_prog_dump_func, suffix: *const ::std::os::raw::c_char);
}
pub type ir_graph_dump_func =
    ::std::option::Option<unsafe extern "C" fn(out: *mut FILE, graph: *mut ir_graph)>;
extern "C" {
    pub fn dump_ir_graph_ext(
        func: ir_graph_dump_func,
        graph: *mut ir_graph,
        suffix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn dump_all_ir_graphs(suffix: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ir_set_dump_path(path: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ir_set_dump_filter(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ir_get_dump_filter() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn dump_ir_graph_file(out: *mut FILE, graph: *mut ir_graph);
}
extern "C" {
    pub fn dump_cfg(out: *mut FILE, graph: *mut ir_graph);
}
extern "C" {
    pub fn dump_callgraph(out: *mut FILE);
}
extern "C" {
    pub fn dump_typegraph(out: *mut FILE);
}
extern "C" {
    pub fn dump_class_hierarchy(out: *mut FILE);
}
extern "C" {
    pub fn dump_loop_tree(out: *mut FILE, graph: *mut ir_graph);
}
extern "C" {
    pub fn dump_callgraph_loop_tree(out: *mut FILE);
}
extern "C" {
    pub fn dump_types_as_text(out: *mut FILE);
}
extern "C" {
    pub fn dump_globals_as_text(out: *mut FILE);
}
extern "C" {
    pub fn dump_loop(out: *mut FILE, loop_: *mut ir_loop);
}
extern "C" {
    pub fn dump_graph_as_text(out: *mut FILE, graph: *const ir_graph);
}
extern "C" {
    pub fn dump_entity_to_file(out: *mut FILE, entity: *const ir_entity);
}
extern "C" {
    pub fn dump_type_to_file(out: *mut FILE, type_: *const ir_type);
}
pub mod ir_dump_verbosity_t {
    pub type Type = u32;
    pub const Onlynames: Type = 1;
    pub const Fields: Type = 2;
    pub const Methods: Type = 4;
    pub const Nostatic: Type = 64;
    pub const Typeattrs: Type = 8;
    pub const Entattrs: Type = 16;
    pub const Entconsts: Type = 32;
    pub const AccessStats: Type = 256;
    pub const Max: Type = 1341132734;
}
extern "C" {
    pub fn ir_set_dump_verbosity(verbosity: ir_dump_verbosity_t::Type);
}
extern "C" {
    pub fn ir_get_dump_verbosity() -> ir_dump_verbosity_t::Type;
}
pub mod ir_dump_flags_t {
    pub type Type = u32;
    pub const BlocksAsSubgraphs: Type = 1;
    pub const WithTypegraph: Type = 2;
    pub const DisableEdgeLabels: Type = 4;
    pub const ConstsLocal: Type = 8;
    pub const IdxLabel: Type = 16;
    pub const NumberLabel: Type = 32;
    pub const KeepaliveEdges: Type = 64;
    pub const OutEdges: Type = 128;
    pub const Dominance: Type = 256;
    pub const Loops: Type = 512;
    pub const BackEdges: Type = 1024;
    pub const Iredges: Type = 2048;
    pub const AllAnchors: Type = 4096;
    pub const ShowMarks: Type = 8192;
    pub const NoEntityValues: Type = 16384;
    pub const LdNames: Type = 32768;
    pub const EntitiesInHierarchy: Type = 65536;
}
extern "C" {
    pub fn ir_set_dump_flags(flags: ir_dump_flags_t::Type);
}
extern "C" {
    pub fn ir_add_dump_flags(flags: ir_dump_flags_t::Type);
}
extern "C" {
    pub fn ir_remove_dump_flags(flags: ir_dump_flags_t::Type);
}
extern "C" {
    pub fn ir_get_dump_flags() -> ir_dump_flags_t::Type;
}
pub type dump_node_vcgattr_func = ::std::option::Option<
    unsafe extern "C" fn(out: *mut FILE, node: *const ir_node, local: *const ir_node)
        -> ::std::os::raw::c_int,
>;
pub type dump_edge_vcgattr_func = ::std::option::Option<
    unsafe extern "C" fn(out: *mut FILE, node: *const ir_node, to: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int,
>;
pub type dump_node_edge_func =
    ::std::option::Option<unsafe extern "C" fn(out: *mut FILE, node: *const ir_node)>;
extern "C" {
    pub fn set_dump_node_vcgattr_hook(hook: dump_node_vcgattr_func);
}
extern "C" {
    pub fn set_dump_edge_vcgattr_hook(hook: dump_edge_vcgattr_func);
}
extern "C" {
    pub fn set_dump_node_edge_hook(func: dump_node_edge_func);
}
extern "C" {
    pub fn get_dump_node_edge_hook() -> dump_node_edge_func;
}
extern "C" {
    pub fn set_dump_block_edge_hook(func: dump_node_edge_func);
}
extern "C" {
    pub fn get_dump_block_edge_hook() -> dump_node_edge_func;
}
pub type dump_node_info_cb_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, out: *mut FILE, n: *const ir_node),
>;
extern "C" {
    pub fn dump_add_node_info_callback(
        cb: dump_node_info_cb_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut hook_entry_t;
}
extern "C" {
    pub fn dump_remove_node_info_callback(handle: *mut hook_entry_t);
}
extern "C" {
    pub fn dump_vcg_header(
        out: *mut FILE,
        name: *const ::std::os::raw::c_char,
        layout: *const ::std::os::raw::c_char,
        orientation: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn dump_vcg_footer(out: *mut FILE);
}
extern "C" {
    pub fn dump_node(out: *mut FILE, node: *const ir_node);
}
extern "C" {
    pub fn dump_ir_data_edges(out: *mut FILE, node: *const ir_node);
}
extern "C" {
    pub fn print_nodeid(out: *mut FILE, node: *const ir_node);
}
extern "C" {
    pub fn dump_begin_block_subgraph(out: *mut FILE, block: *const ir_node);
}
extern "C" {
    pub fn dump_end_block_subgraph(out: *mut FILE, block: *const ir_node);
}
extern "C" {
    pub fn dump_block_edges(out: *mut FILE, block: *const ir_node);
}
extern "C" {
    pub fn dump_blocks_as_subgraphs(out: *mut FILE, irg: *mut ir_graph);
}
pub mod ir_edge_kind_t {
    pub type Type = u32;
    pub const Normal: Type = 0;
    pub const First: Type = 0;
    pub const Block: Type = 1;
    pub const Last: Type = 1;
}
extern "C" {
    pub fn get_irn_out_edge_first_kind(
        irn: *const ir_node,
        kind: ir_edge_kind_t::Type,
    ) -> *const ir_edge_t;
}
extern "C" {
    pub fn get_irn_out_edge_first(irn: *const ir_node) -> *const ir_edge_t;
}
extern "C" {
    pub fn get_block_succ_first(block: *const ir_node) -> *const ir_edge_t;
}
extern "C" {
    pub fn get_irn_out_edge_next(
        irn: *const ir_node,
        last: *const ir_edge_t,
        kind: ir_edge_kind_t::Type,
    ) -> *const ir_edge_t;
}
extern "C" {
    pub fn get_edge_src_irn(edge: *const ir_edge_t) -> *mut ir_node;
}
extern "C" {
    pub fn get_edge_src_pos(edge: *const ir_edge_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_irn_n_edges_kind(
        irn: *const ir_node,
        kind: ir_edge_kind_t::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_irn_n_edges(irn: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edges_activated_kind(
        irg: *const ir_graph,
        kind: ir_edge_kind_t::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edges_activated(irg: *const ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edges_activate_kind(irg: *mut ir_graph, kind: ir_edge_kind_t::Type);
}
extern "C" {
    pub fn edges_deactivate_kind(irg: *mut ir_graph, kind: ir_edge_kind_t::Type);
}
extern "C" {
    pub fn edges_reroute_kind(old: *mut ir_node, nw: *mut ir_node, kind: ir_edge_kind_t::Type);
}
extern "C" {
    pub fn edges_reroute(old: *mut ir_node, nw: *mut ir_node);
}
extern "C" {
    pub fn edges_reroute_except(old: *mut ir_node, nw: *mut ir_node, exception: *mut ir_node);
}
extern "C" {
    pub fn edges_verify(irg: *mut ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edges_verify_kind(
        irg: *mut ir_graph,
        kind: ir_edge_kind_t::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edges_init_dbg(do_dbg: ::std::os::raw::c_int);
}
extern "C" {
    pub fn edges_activate(irg: *mut ir_graph);
}
extern "C" {
    pub fn edges_deactivate(irg: *mut ir_graph);
}
extern "C" {
    pub fn assure_edges(irg: *mut ir_graph);
}
extern "C" {
    pub fn assure_edges_kind(irg: *mut ir_graph, kind: ir_edge_kind_t::Type);
}
extern "C" {
    pub fn irg_block_edges_walk(
        block: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_edges(
        start: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
pub type optimization_state_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn set_optimize(value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_optimize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_opt_constant_folding(value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_opt_constant_folding() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_opt_algebraic_simplification(value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_opt_algebraic_simplification() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_opt_cse(value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_opt_cse() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_opt_global_cse(value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_opt_global_cse() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_opt_global_null_ptr_elimination(value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_opt_global_null_ptr_elimination() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn save_optimization_state(state: *mut optimization_state_t);
}
extern "C" {
    pub fn restore_optimization_state(state: *const optimization_state_t);
}
extern "C" {
    pub fn all_optimizations_off();
}
extern "C" {
    pub fn exchange(old: *mut ir_node, nw: *mut ir_node);
}
extern "C" {
    pub fn turn_into_tuple(
        node: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    );
}
extern "C" {
    pub fn collect_phiprojs_and_start_block_nodes(irg: *mut ir_graph);
}
extern "C" {
    pub fn collect_new_start_block_node(node: *mut ir_node);
}
extern "C" {
    pub fn collect_new_phi_node(node: *mut ir_node);
}
extern "C" {
    pub fn part_block(node: *mut ir_node);
}
extern "C" {
    pub fn part_block_edges(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn kill_node(node: *mut ir_node);
}
extern "C" {
    pub fn duplicate_subgraph(
        dbg: *mut dbg_info,
        n: *mut ir_node,
        to_block: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn local_optimize_node(n: *mut ir_node);
}
extern "C" {
    pub fn optimize_node(n: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn local_optimize_graph(irg: *mut ir_graph);
}
extern "C" {
    pub fn optimize_graph_df(irg: *mut ir_graph);
}
extern "C" {
    pub fn local_opts_const_code();
}
extern "C" {
    pub fn remove_unreachable_code(irg: *mut ir_graph);
}
extern "C" {
    pub fn remove_bads(irg: *mut ir_graph);
}
extern "C" {
    pub fn remove_tuples(irg: *mut ir_graph);
}
extern "C" {
    pub fn remove_critical_cf_edges(irg: *mut ir_graph);
}
extern "C" {
    pub fn remove_critical_cf_edges_ex(
        irg: *mut ir_graph,
        ignore_exception_edges: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn new_ir_graph(ent: *mut ir_entity, n_loc: ::std::os::raw::c_int) -> *mut ir_graph;
}
extern "C" {
    pub fn free_ir_graph(irg: *mut ir_graph);
}
extern "C" {
    pub fn get_irg_entity(irg: *const ir_graph) -> *mut ir_entity;
}
extern "C" {
    pub fn set_irg_entity(irg: *mut ir_graph, ent: *mut ir_entity);
}
extern "C" {
    pub fn get_irg_frame_type(irg: *mut ir_graph) -> *mut ir_type;
}
extern "C" {
    pub fn set_irg_frame_type(irg: *mut ir_graph, ftp: *mut ir_type);
}
extern "C" {
    pub fn get_irg_start_block(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn set_irg_start_block(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    pub fn get_irg_start(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn set_irg_start(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    pub fn get_irg_end_block(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn set_irg_end_block(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    pub fn get_irg_end(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn set_irg_end(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    pub fn get_irg_frame(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn set_irg_frame(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    pub fn get_irg_initial_mem(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn set_irg_initial_mem(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    pub fn get_irg_args(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn set_irg_args(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    pub fn get_irg_no_mem(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    pub fn set_irg_no_mem(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    pub fn get_irg_n_locs(irg: *mut ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_irg_graph_nr(irg: *const ir_graph) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn get_irg_idx(irg: *const ir_graph) -> usize;
}
extern "C" {
    pub fn get_idx_irn(irg: *const ir_graph, idx: ::std::os::raw::c_uint) -> *mut ir_node;
}
extern "C" {
    pub fn get_irg_pinned(irg: *const ir_graph) -> op_pin_state::Type;
}
pub mod irg_callee_info_state {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const Consistent: Type = 1;
    pub const Inconsistent: Type = 2;
}
extern "C" {
    pub fn get_irg_callee_info_state(irg: *const ir_graph) -> irg_callee_info_state::Type;
}
extern "C" {
    pub fn set_irg_callee_info_state(irg: *mut ir_graph, s: irg_callee_info_state::Type);
}
extern "C" {
    pub fn set_irg_link(irg: *mut ir_graph, thing: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn get_irg_link(irg: *const ir_graph) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inc_irg_visited(irg: *mut ir_graph);
}
extern "C" {
    pub fn get_irg_visited(irg: *const ir_graph) -> ir_visited_t;
}
extern "C" {
    pub fn set_irg_visited(irg: *mut ir_graph, i: ir_visited_t);
}
extern "C" {
    pub fn get_max_irg_visited() -> ir_visited_t;
}
extern "C" {
    pub fn set_max_irg_visited(val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn inc_max_irg_visited() -> ir_visited_t;
}
extern "C" {
    pub fn inc_irg_block_visited(irg: *mut ir_graph);
}
extern "C" {
    pub fn get_irg_block_visited(irg: *const ir_graph) -> ir_visited_t;
}
extern "C" {
    pub fn set_irg_block_visited(irg: *mut ir_graph, i: ir_visited_t);
}
pub mod ir_resources_t {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const BlockVisited: Type = 1;
    pub const BlockMark: Type = 2;
    pub const IrnVisited: Type = 4;
    pub const IrnLink: Type = 8;
    pub const LoopLink: Type = 16;
    pub const PhiList: Type = 32;
}
extern "C" {
    pub fn ir_reserve_resources(irg: *mut ir_graph, resources: ir_resources_t::Type);
}
extern "C" {
    pub fn ir_free_resources(irg: *mut ir_graph, resources: ir_resources_t::Type);
}
extern "C" {
    pub fn ir_resources_reserved(irg: *const ir_graph) -> ir_resources_t::Type;
}
pub mod ir_graph_constraints_t {
    pub type Type = u32;
    pub const ArchDep: Type = 1;
    pub const ModebLowered: Type = 2;
    pub const Normalisation2: Type = 4;
    pub const OptimizeUnreachableCode: Type = 8;
    pub const Construction: Type = 16;
    pub const TargetLowered: Type = 32;
    pub const Backend: Type = 64;
}
extern "C" {
    pub fn add_irg_constraints(irg: *mut ir_graph, constraints: ir_graph_constraints_t::Type);
}
extern "C" {
    pub fn clear_irg_constraints(irg: *mut ir_graph, constraints: ir_graph_constraints_t::Type);
}
extern "C" {
    pub fn irg_is_constrained(
        irg: *const ir_graph,
        constraints: ir_graph_constraints_t::Type,
    ) -> ::std::os::raw::c_int;
}
pub mod ir_graph_properties_t {
    pub type Type = u32;
    pub const IrGraphPropertiesNone: Type = 0;
    pub const NoCriticalEdges: Type = 1;
    pub const NoBads: Type = 2;
    pub const NoTuples: Type = 4;
    pub const NoUnreachableCode: Type = 8;
    pub const OneReturn: Type = 16;
    pub const ConsistentDominance: Type = 32;
    pub const ConsistentPostdominance: Type = 64;
    pub const ConsistentDominanceFrontiers: Type = 128;
    pub const ConsistentOutEdges: Type = 256;
    pub const ConsistentOuts: Type = 512;
    pub const ConsistentLoopinfo: Type = 1024;
    pub const ConsistentEntityUsage: Type = 2048;
    pub const ManyReturns: Type = 4096;
    pub const IrGraphPropertiesControlFlow: Type = 1273;
    pub const IrGraphPropertiesAll: Type = 8191;
}
extern "C" {
    pub fn add_irg_properties(irg: *mut ir_graph, props: ir_graph_properties_t::Type);
}
extern "C" {
    pub fn clear_irg_properties(irg: *mut ir_graph, props: ir_graph_properties_t::Type);
}
extern "C" {
    pub fn irg_has_properties(
        irg: *const ir_graph,
        props: ir_graph_properties_t::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_irg_loc_description(
        irg: *mut ir_graph,
        n: ::std::os::raw::c_int,
        description: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn get_irg_loc_description(
        irg: *mut ir_graph,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_irg_last_idx(irg: *const ir_graph) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn assure_irg_properties(irg: *mut ir_graph, props: ir_graph_properties_t::Type);
}
extern "C" {
    pub fn confirm_irg_properties(irg: *mut ir_graph, props: ir_graph_properties_t::Type);
}
extern "C" {
    pub fn irg_walk(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_core(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_graph(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_in_or_dep(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_in_or_dep_graph(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_topological(
        irg: *mut ir_graph,
        walker: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn all_irg_walk(pre: irg_walk_func, post: irg_walk_func, env: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn irg_block_walk(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_block_walk_graph(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn walk_const_code(
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_blkwise_graph(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_blkwise_dom_top_down(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_anchors(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_walk_2(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ir_export(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_export_file(output: *mut FILE);
}
extern "C" {
    pub fn ir_import(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_import_file(
        input: *mut FILE,
        inputname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_backedge(n: *const ir_node, pos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_backedge(n: *mut ir_node, pos: ::std::os::raw::c_int);
}
extern "C" {
    pub fn has_backedges(n: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clear_backedges(n: *mut ir_node);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union loop_element {
    pub kind: *mut firm_kind::Type,
    pub node: *mut ir_node,
    pub son: *mut ir_loop,
    pub irg: *mut ir_graph,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_loop_element() {
    assert_eq!(
        ::std::mem::size_of::<loop_element>(),
        8usize,
        concat!("Size of: ", stringify!(loop_element))
    );
    assert_eq!(
        ::std::mem::align_of::<loop_element>(),
        8usize,
        concat!("Alignment of ", stringify!(loop_element))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<loop_element>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loop_element),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<loop_element>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loop_element),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<loop_element>())).son as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loop_element),
            "::",
            stringify!(son)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<loop_element>())).irg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loop_element),
            "::",
            stringify!(irg)
        )
    );
}
extern "C" {
    pub fn set_irg_loop(irg: *mut ir_graph, l: *mut ir_loop);
}
extern "C" {
    pub fn get_irg_loop(irg: *const ir_graph) -> *mut ir_loop;
}
extern "C" {
    pub fn get_irn_loop(n: *const ir_node) -> *mut ir_loop;
}
extern "C" {
    pub fn get_loop_outer_loop(loop_: *const ir_loop) -> *mut ir_loop;
}
extern "C" {
    pub fn get_loop_depth(loop_: *const ir_loop) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_loop_n_elements(loop_: *const ir_loop) -> usize;
}
extern "C" {
    pub fn get_loop_element(loop_: *const ir_loop, pos: usize) -> loop_element;
}
extern "C" {
    pub fn get_loop_loop_nr(loop_: *const ir_loop) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn set_loop_link(loop_: *mut ir_loop, link: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn get_loop_link(loop_: *const ir_loop) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn construct_cf_backedges(irg: *mut ir_graph);
}
extern "C" {
    pub fn assure_loopinfo(irg: *mut ir_graph);
}
extern "C" {
    pub fn free_loop_information(irg: *mut ir_graph);
}
extern "C" {
    pub fn is_loop_invariant(n: *const ir_node, block: *const ir_node) -> ::std::os::raw::c_int;
}
pub mod ir_alias_relation {
    pub type Type = u32;
    pub const NoAlias: Type = 0;
    pub const MayAlias: Type = 1;
    pub const SureAlias: Type = 2;
}
pub mod ir_entity_usage_computed_state {
    pub type Type = u32;
    pub const NotComputed: Type = 0;
    pub const Computed: Type = 1;
}
pub mod ir_disambiguator_options {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const AlwaysAlias: Type = 1;
    pub const TypeBased: Type = 2;
    pub const ByteTypeMayAlias: Type = 4;
    pub const NoAlias: Type = 8;
    pub const Inherited: Type = 16;
}
extern "C" {
    pub fn get_ir_alias_relation_name(
        rel: ir_alias_relation::Type,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_alias_relation(
        addr1: *const ir_node,
        type1: *const ir_type,
        size1: ::std::os::raw::c_uint,
        addr2: *const ir_node,
        type2: *const ir_type,
        size2: ::std::os::raw::c_uint,
    ) -> ir_alias_relation::Type;
}
extern "C" {
    pub fn assure_irg_entity_usage_computed(irg: *mut ir_graph);
}
extern "C" {
    pub fn get_irp_globals_entity_usage_state() -> ir_entity_usage_computed_state::Type;
}
extern "C" {
    pub fn set_irp_globals_entity_usage_state(state: ir_entity_usage_computed_state::Type);
}
extern "C" {
    pub fn assure_irp_globals_entity_usage_computed();
}
extern "C" {
    pub fn get_irg_memory_disambiguator_options(
        irg: *const ir_graph,
    ) -> ir_disambiguator_options::Type;
}
extern "C" {
    pub fn set_irg_memory_disambiguator_options(
        irg: *mut ir_graph,
        options: ir_disambiguator_options::Type,
    );
}
extern "C" {
    pub fn set_irp_memory_disambiguator_options(options: ir_disambiguator_options::Type);
}
extern "C" {
    pub fn mark_private_methods();
}
extern "C" {
    pub fn computed_value(n: *const ir_node) -> *mut ir_tarval;
}
extern "C" {
    pub fn optimize_in_place(n: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    pub fn ir_is_negated_value(a: *const ir_node, b: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_get_possible_cmp_relations(
        left: *const ir_node,
        right: *const ir_node,
    ) -> ir_relation::Type;
}
extern "C" {
    pub fn ir_allow_imprecise_float_transforms(enable: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ir_imprecise_float_transforms_allowed() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_irn_n_outs(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_irn_out(def: *const ir_node, pos: ::std::os::raw::c_uint) -> *mut ir_node;
}
extern "C" {
    pub fn get_irn_out_ex(
        def: *const ir_node,
        pos: ::std::os::raw::c_uint,
        in_pos: *mut ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn get_Block_n_cfg_outs(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_Block_n_cfg_outs_ka(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn get_Block_cfg_out(node: *const ir_node, pos: ::std::os::raw::c_uint) -> *mut ir_node;
}
extern "C" {
    pub fn get_Block_cfg_out_ex(
        node: *const ir_node,
        pos: ::std::os::raw::c_uint,
        in_pos: *mut ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    pub fn get_Block_cfg_out_ka(node: *const ir_node, pos: ::std::os::raw::c_uint) -> *mut ir_node;
}
extern "C" {
    pub fn irg_out_walk(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn irg_out_block_walk(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn compute_irg_outs(irg: *mut ir_graph);
}
extern "C" {
    pub fn assure_irg_outs(irg: *mut ir_graph);
}
extern "C" {
    pub fn free_irg_outs(irg: *mut ir_graph);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ir_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_fprintf(
        f: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_snprintf(
        buf: *mut ::std::os::raw::c_char,
        n: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_vprintf(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_vfprintf(
        f: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        len: usize,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_obst_vprintf(
        obst: *mut obstack,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        tv: *const ir_tarval,
    ) -> ::std::os::raw::c_int;
}
pub mod ir_segment_t {
    pub type Type = u32;
    pub const First: Type = 0;
    pub const Global: Type = 0;
    pub const ThreadLocal: Type = 1;
    pub const Constructors: Type = 2;
    pub const Destructors: Type = 3;
    pub const Jcr: Type = 4;
    pub const Last: Type = 4;
}
extern "C" {
    #[link_name = "\u{1}irp"]
    pub static mut irp: *mut ir_prog;
}
pub mod irp_resources_t {
    pub type Type = u32;
    pub const None: Type = 0;
    pub const IrgLink: Type = 1;
    pub const EntityLink: Type = 2;
    pub const TypeVisited: Type = 4;
    pub const TypeLink: Type = 8;
}
extern "C" {
    pub fn irp_reserve_resources(irp: *mut ir_prog, resources: irp_resources_t::Type);
}
extern "C" {
    pub fn irp_free_resources(irp: *mut ir_prog, resources: irp_resources_t::Type);
}
extern "C" {
    pub fn irp_resources_reserved(irp: *const ir_prog) -> irp_resources_t::Type;
}
extern "C" {
    pub fn get_irp() -> *mut ir_prog;
}
extern "C" {
    pub fn set_irp(irp: *mut ir_prog);
}
extern "C" {
    pub fn new_ir_prog(name: *const ::std::os::raw::c_char) -> *mut ir_prog;
}
extern "C" {
    pub fn free_ir_prog();
}
extern "C" {
    pub fn set_irp_prog_name(name: *mut ident);
}
extern "C" {
    pub fn irp_prog_name_is_set() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_irp_ident() -> *mut ident;
}
extern "C" {
    pub fn get_irp_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_irp_main_irg() -> *mut ir_graph;
}
extern "C" {
    pub fn set_irp_main_irg(main_irg: *mut ir_graph);
}
extern "C" {
    pub fn get_irp_last_idx() -> usize;
}
extern "C" {
    pub fn get_irp_n_irgs() -> usize;
}
extern "C" {
    pub fn get_irp_irg(pos: usize) -> *mut ir_graph;
}
extern "C" {
    pub fn set_irp_irg(pos: usize, irg: *mut ir_graph);
}
extern "C" {
    pub fn get_segment_type(segment: ir_segment_t::Type) -> *mut ir_type;
}
extern "C" {
    pub fn set_segment_type(segment: ir_segment_t::Type, new_type: *mut ir_type);
}
extern "C" {
    pub fn get_glob_type() -> *mut ir_type;
}
extern "C" {
    pub fn get_tls_type() -> *mut ir_type;
}
extern "C" {
    pub fn ir_get_global(name: *mut ident) -> *mut ir_entity;
}
extern "C" {
    pub fn get_irp_n_types() -> usize;
}
extern "C" {
    pub fn get_irp_type(pos: usize) -> *mut ir_type;
}
extern "C" {
    pub fn set_irp_type(pos: usize, typ: *mut ir_type);
}
extern "C" {
    pub fn get_const_code_irg() -> *mut ir_graph;
}
extern "C" {
    pub fn get_irp_callee_info_state() -> irg_callee_info_state::Type;
}
extern "C" {
    pub fn set_irp_callee_info_state(s: irg_callee_info_state::Type);
}
extern "C" {
    pub fn get_irp_next_label_nr() -> ir_label_t;
}
extern "C" {
    pub fn add_irp_asm(asm_string: *mut ident);
}
extern "C" {
    pub fn get_irp_n_asms() -> usize;
}
extern "C" {
    pub fn get_irp_asm(pos: usize) -> *mut ident;
}
extern "C" {
    pub fn irn_verify(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn irg_verify(irg: *mut ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn irg_assert_verify(irg: *mut ir_graph);
}
extern "C" {
    pub fn lower_CopyB(
        irg: *mut ir_graph,
        max_small_size: ::std::os::raw::c_uint,
        min_large_size: ::std::os::raw::c_uint,
        allow_misalignments: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn lower_switch(
        irg: *mut ir_graph,
        small_switch: ::std::os::raw::c_uint,
        spare_size: ::std::os::raw::c_uint,
        selector_mode: *mut ir_mode,
    );
}
extern "C" {
    pub fn lower_highlevel_graph(irg: *mut ir_graph);
}
extern "C" {
    pub fn lower_highlevel();
}
extern "C" {
    pub fn lower_const_code();
}
pub type lower_mux_callback =
    ::std::option::Option<unsafe extern "C" fn(mux: *mut ir_node) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn lower_mux(irg: *mut ir_graph, cb_func: lower_mux_callback);
}
pub type i_mapper_func =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ir_node) -> ::std::os::raw::c_int>;
pub mod ikind {
    pub type Type = u32;
    pub const Call: Type = 0;
    pub const Instr: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i_call_record {
    pub kind: ikind::Type,
    pub i_ent: *mut ir_entity,
    pub i_mapper: i_mapper_func,
}
#[test]
fn bindgen_test_layout_i_call_record() {
    assert_eq!(
        ::std::mem::size_of::<i_call_record>(),
        24usize,
        concat!("Size of: ", stringify!(i_call_record))
    );
    assert_eq!(
        ::std::mem::align_of::<i_call_record>(),
        8usize,
        concat!("Alignment of ", stringify!(i_call_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i_call_record>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_call_record),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i_call_record>())).i_ent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i_call_record),
            "::",
            stringify!(i_ent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i_call_record>())).i_mapper as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i_call_record),
            "::",
            stringify!(i_mapper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i_instr_record {
    pub kind: ikind::Type,
    pub op: *mut ir_op,
    pub i_mapper: i_mapper_func,
}
#[test]
fn bindgen_test_layout_i_instr_record() {
    assert_eq!(
        ::std::mem::size_of::<i_instr_record>(),
        24usize,
        concat!("Size of: ", stringify!(i_instr_record))
    );
    assert_eq!(
        ::std::mem::align_of::<i_instr_record>(),
        8usize,
        concat!("Alignment of ", stringify!(i_instr_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i_instr_record>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_instr_record),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i_instr_record>())).op as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i_instr_record),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i_instr_record>())).i_mapper as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i_instr_record),
            "::",
            stringify!(i_mapper)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i_record {
    pub kind: ikind::Type,
    pub i_call: i_call_record,
    pub i_instr: i_instr_record,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_i_record() {
    assert_eq!(
        ::std::mem::size_of::<i_record>(),
        24usize,
        concat!("Size of: ", stringify!(i_record))
    );
    assert_eq!(
        ::std::mem::align_of::<i_record>(),
        8usize,
        concat!("Alignment of ", stringify!(i_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i_record>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_record),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i_record>())).i_call as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_record),
            "::",
            stringify!(i_call)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i_record>())).i_instr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_record),
            "::",
            stringify!(i_instr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_intrinsics_map {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ir_create_intrinsics_map(
        list: *mut i_record,
        length: usize,
        part_block_used: ::std::os::raw::c_int,
    ) -> *mut ir_intrinsics_map;
}
extern "C" {
    pub fn ir_free_intrinsics_map(map: *mut ir_intrinsics_map);
}
extern "C" {
    pub fn ir_lower_intrinsics(irg: *mut ir_graph, map: *mut ir_intrinsics_map);
}
extern "C" {
    pub fn i_mapper_abs(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_sqrt(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_cbrt(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_pow(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_exp(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_exp2(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_exp10(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_log(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_log2(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_log10(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_sin(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_cos(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_tan(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_asin(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_acos(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_atan(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_sinh(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_cosh(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_tanh(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_strcmp(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_strncmp(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_strcpy(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_strlen(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_memcpy(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_memmove(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_memset(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i_mapper_memcmp(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_target_set(target_triple: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_target_set_triple(machine: *const ir_machine_triple_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_target_option(option: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_target_init();
}
extern "C" {
    pub fn ir_target_experimental() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_target_big_endian() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_target_biggest_alignment() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_target_pointer_size() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_target_supports_pic() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_target_fast_unaligned_memaccess() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_target_float_arithmetic_mode() -> *mut ir_mode;
}
extern "C" {
    pub fn ir_target_float_int_overflow_style() -> float_int_conversion_overflow_style_t::Type;
}
pub mod ir_platform_type_t {
    pub type Type = u32;
    pub const Bool: Type = 0;
    pub const Char: Type = 1;
    pub const Short: Type = 2;
    pub const Int: Type = 3;
    pub const Long: Type = 4;
    pub const LongLong: Type = 5;
    pub const Float: Type = 6;
    pub const Double: Type = 7;
    pub const LongDouble: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_platform_define_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ir_platform_long_long_and_double_struct_align_override() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_platform_pic_is_default() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_platform_supports_thread_local_storage() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_platform_define_value(
        define: *const ir_platform_define_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_platform_wchar_type() -> ir_platform_type_t::Type;
}
extern "C" {
    pub fn ir_platform_wchar_is_signed() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_platform_intptr_type() -> ir_platform_type_t::Type;
}
extern "C" {
    pub fn ir_platform_type_size(type_: ir_platform_type_t::Type) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_platform_type_align(type_: ir_platform_type_t::Type) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ir_platform_type_mode(
        type_: ir_platform_type_t::Type,
        is_signed: ::std::os::raw::c_int,
    ) -> *mut ir_mode;
}
extern "C" {
    pub fn ir_platform_va_list_type() -> *mut ir_type;
}
extern "C" {
    pub fn ir_platform_user_label_prefix() -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_platform_default_exe_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_platform_mangle_global(name: *const ::std::os::raw::c_char) -> *mut ident;
}
extern "C" {
    pub fn ir_platform_define_first() -> *const ir_platform_define_t;
}
extern "C" {
    pub fn ir_platform_define_next(
        define: *const ir_platform_define_t,
    ) -> *const ir_platform_define_t;
}
extern "C" {
    pub fn ir_platform_define_name(
        define: *const ir_platform_define_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_parse_machine_triple(
        triple_string: *const ::std::os::raw::c_char,
    ) -> *mut ir_machine_triple_t;
}
extern "C" {
    pub fn ir_get_host_machine_triple() -> *mut ir_machine_triple_t;
}
extern "C" {
    pub fn ir_triple_get_cpu_type(
        triple: *const ir_machine_triple_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_triple_get_manufacturer(
        triple: *const ir_machine_triple_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_triple_get_operating_system(
        triple: *const ir_machine_triple_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ir_triple_set_cpu_type(
        triple: *mut ir_machine_triple_t,
        cpu_type: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ir_free_machine_triple(triple: *mut ir_machine_triple_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_timer_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ir_timer_enter_high_priority() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_timer_leave_high_priority() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ir_timer_new() -> *mut ir_timer_t;
}
extern "C" {
    pub fn ir_timer_free(timer: *mut ir_timer_t);
}
extern "C" {
    pub fn ir_timer_start(timer: *mut ir_timer_t);
}
extern "C" {
    pub fn ir_timer_reset_and_start(timer: *mut ir_timer_t);
}
extern "C" {
    pub fn ir_timer_reset(timer: *mut ir_timer_t);
}
extern "C" {
    pub fn ir_timer_stop(timer: *mut ir_timer_t);
}
extern "C" {
    pub fn ir_timer_init_parent(timer: *mut ir_timer_t);
}
extern "C" {
    pub fn ir_timer_push(timer: *mut ir_timer_t);
}
extern "C" {
    pub fn ir_timer_pop(timer: *mut ir_timer_t);
}
extern "C" {
    pub fn ir_timer_elapsed_msec(timer: *const ir_timer_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ir_timer_elapsed_usec(timer: *const ir_timer_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ir_timer_elapsed_sec(timer: *const ir_timer_t) -> f64;
}
extern "C" {
    pub fn new_tarval_from_str(
        str: *const ::std::os::raw::c_char,
        len: usize,
        mode: *mut ir_mode,
    ) -> *mut ir_tarval;
}
extern "C" {
    pub fn new_integer_tarval_from_str(
        str: *const ::std::os::raw::c_char,
        len: usize,
        negative: ::std::os::raw::c_int,
        base: ::std::os::raw::c_uchar,
        mode: *mut ir_mode,
    ) -> *mut ir_tarval;
}
extern "C" {
    pub fn new_tarval_from_long(l: ::std::os::raw::c_long, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn new_tarval_from_bytes(
        buf: *const ::std::os::raw::c_uchar,
        mode: *mut ir_mode,
    ) -> *mut ir_tarval;
}
extern "C" {
    pub fn new_tarval_nan(
        mode: *mut ir_mode,
        signaling: ::std::os::raw::c_int,
        payload: *const ir_tarval,
    ) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_to_bytes(buffer: *mut ::std::os::raw::c_uchar, tv: *const ir_tarval);
}
extern "C" {
    pub fn get_tarval_long(tv: *const ir_tarval) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tarval_is_long(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn new_tarval_from_double(d: f64, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn new_tarval_from_long_double(d: f64, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn get_tarval_double(tv: *const ir_tarval) -> f64;
}
extern "C" {
    pub fn get_tarval_long_double(tv: *const ir_tarval) -> f64;
}
extern "C" {
    pub fn tarval_is_double(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_tarval_mode(tv: *const ir_tarval) -> *mut ir_mode;
}
extern "C" {
    pub fn tarval_is_negative(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_is_null(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_is_one(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_is_all_one(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_is_constant(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}tarval_bad"]
    pub static mut tarval_bad: *mut ir_tarval;
}
extern "C" {
    pub fn get_tarval_bad() -> *mut ir_tarval;
}
extern "C" {
    #[link_name = "\u{1}tarval_unknown"]
    pub static mut tarval_unknown: *mut ir_tarval;
}
extern "C" {
    pub fn get_tarval_unknown() -> *mut ir_tarval;
}
extern "C" {
    #[link_name = "\u{1}tarval_b_false"]
    pub static mut tarval_b_false: *mut ir_tarval;
}
extern "C" {
    pub fn get_tarval_b_false() -> *mut ir_tarval;
}
extern "C" {
    #[link_name = "\u{1}tarval_b_true"]
    pub static mut tarval_b_true: *mut ir_tarval;
}
extern "C" {
    pub fn get_tarval_b_true() -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_set_wrap_on_overflow(wrap_on_overflow: ::std::os::raw::c_int);
}
extern "C" {
    pub fn tarval_get_wrap_on_overflow() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_cmp(a: *const ir_tarval, b: *const ir_tarval) -> ir_relation::Type;
}
extern "C" {
    pub fn tarval_convert_to(src: *const ir_tarval, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_bitcast(src: *const ir_tarval, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_not(a: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_neg(a: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_add(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_sub(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_mul(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_div(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_mod(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_divmod(
        a: *const ir_tarval,
        b: *const ir_tarval,
        mod_res: *mut *mut ir_tarval,
    ) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_abs(a: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_and(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_andnot(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_or(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_ornot(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_eor(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_shl(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_shl_unsigned(a: *const ir_tarval, b: ::std::os::raw::c_uint) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_shr(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_shr_unsigned(a: *const ir_tarval, b: ::std::os::raw::c_uint) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_shrs(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    pub fn tarval_shrs_unsigned(a: *const ir_tarval, b: ::std::os::raw::c_uint) -> *mut ir_tarval;
}
extern "C" {
    pub fn get_tarval_sub_bits(
        tv: *const ir_tarval,
        byte_ofs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn get_tarval_popcount(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_tarval_lowest_bit(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_tarval_highest_bit(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_zero_mantissa(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_get_exponent(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_ieee754_can_conv_lossless(
        tv: *const ir_tarval,
        mode: *const ir_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_ieee754_get_exact() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn tarval_is_nan(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_is_quiet_nan(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_is_signaling_nan(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tarval_is_finite(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
pub mod range_types {
    pub type Type = u32;
    pub const Undefined: Type = 0;
    pub const Range: Type = 1;
    pub const Antirange: Type = 2;
    pub const Varying: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrp_attr {
    pub bits_set: *mut ir_tarval,
    pub bits_not_set: *mut ir_tarval,
    pub range_type: range_types::Type,
    pub range_bottom: *mut ir_tarval,
    pub range_top: *mut ir_tarval,
}
#[test]
fn bindgen_test_layout_vrp_attr() {
    assert_eq!(
        ::std::mem::size_of::<vrp_attr>(),
        40usize,
        concat!("Size of: ", stringify!(vrp_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<vrp_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(vrp_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrp_attr>())).bits_set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(bits_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrp_attr>())).bits_not_set as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(bits_not_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrp_attr>())).range_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(range_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrp_attr>())).range_bottom as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(range_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrp_attr>())).range_top as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(range_top)
        )
    );
}
extern "C" {
    pub fn set_vrp_data(irg: *mut ir_graph);
}
extern "C" {
    pub fn free_vrp_data(irg: *mut ir_graph);
}
extern "C" {
    pub fn vrp_cmp(left: *const ir_node, right: *const ir_node) -> ir_relation::Type;
}
extern "C" {
    pub fn vrp_get_info(n: *const ir_node) -> *mut vrp_attr;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
