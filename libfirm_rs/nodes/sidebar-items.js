initSidebarItems({"enum":[["NewKind",""],["Node",""],["ProjKind",""],["VisitTime",""]],"fn":[["get_Block_dom_depth",""],["internal_try_as_value_node",""],["try_as_bin_op",""],["try_as_unary_op",""],["try_as_value_node",""]],"struct":[["Add","returns the sum of its operands"],["Address","Symbolic constant that represents the address of an entity (variable or method)"],["Align","A symbolic constant that represents the alignment of a type"],["Alloc","Allocates a block of memory on the stack."],["Anchor","Utility node used to \"hold\" nodes in a graph that might possibly not be reachable by other means or which should be reachable immediately without searching through the graph. Each firm-graph contains exactly one anchor node whose address is always known. All other well-known graph-nodes like Start, End, NoMem, ... are found by looking at the respective Anchor operand."],["And","returns the result of a bitwise and operation of its operands"],["Bad","Bad nodes indicate invalid input, which is values which should never be computed."],["Bitcast","Converts a value between modes with different arithmetics but same number of bits by reinterpreting the bits in the new mode"],["Block","A basic block"],["Builtin","performs a backend-specific builtin."],["Call","Calls other code. Control flow is transferred to ptr, additional operands are passed to the called code. Called code usually performs a return operation. The operands of this return operation are the result of the Call node."],["CallArgsIterator",""],["CfgPredsIterator",""],["Cmp","Compares its two operands and checks whether a specified relation (like less or equal) is fulfilled."],["Cond","Conditionally change control flow."],["Confirm","Specifies constraints for a value. This allows explicit representation of path-sensitive properties. (Example: This value is always >= 0 on 1 if-branch then all users within that branch are rerouted to a confirm-node specifying this property)."],["Const","Returns a constant value."],["Conv","Converts values between modes"],["CopyB","Copies a block of memory with statically known size/type."],["Deleted","Internal node which is temporary set to nodes which are already removed from the graph."],["Div","returns the quotient of its 2 operands"],["DowncastErr",""],["Dummy","A placeholder value. This is used when constructing cyclic graphs where you have cases where not all predecessors of a phi-node are known. Dummy nodes are used for the unknown predecessors and replaced later."],["End","Last node of a graph. It references nodes in endless loops (so called keepalive edges)"],["EndKeepAliveIterator",""],["Eor","returns the result of a bitwise exclusive or operation of its operands."],["Free","Frees a block of memory previously allocated by an Alloc node"],["IJmp","Jumps to the code in its argument. The code has to be in the same function and the destination must be one of the blocks reachable by the tuple results"],["Id","Returns its operand unchanged."],["InNodeIterator",""],["Jmp","Jumps to the block connected through the out-value"],["Load","Loads a value from memory (heap or stack)."],["Member","Computes the address of a compound type member given the base address of an instance of the compound type."],["Minus","returns the additive inverse of its operand"],["Mod","returns the remainder of its operands from an implied division."],["Mul","returns the product of its operands"],["Mulh","returns the upper word of the product of its operands (the part which would not fit into the result mode of a normal Mul anymore)"],["Mux","returns the false or true operand depending on the value of the sel operand"],["NoMem","Placeholder node for cases where you don't need any memory input"],["NodeDebugFmt",""],["NodeDebugOpts",""],["NodeFactory",""],["Not","returns the bitwise complement of a value. Works for boolean values, too."],["Offset","Symbolic constant that represents the offset of an entity in its owner type."],["Or","returns the result of a bitwise or operation of its operands"],["OutNodeExIterator",""],["OutNodeIterator",""],["Phi","Choose a value based on control flow. A phi node has 1 input for each predecessor of its block. If a block is entered from its nth predecessor all phi nodes produce their nth input as result."],["PhiPredsIterator",""],["PhisOfBlockLinkedListIterator",""],["Pin","Pin the value of the node node in the current block. No users of the Pin node can float above the Block of the Pin. The node cannot float behind this block. Often used to Pin the NoMem node."],["Proj","returns an entry of a tuple value"],["Raise","Raises an exception. Unconditional change of control flow. Writes an explicit Except variable to memory to pass it to the exception handler. Must be lowered to a Call to a runtime check function."],["Return","Returns from the current function. Takes memory and return values as operands."],["ReturnResIterator",""],["Sel","Computes the address of an array element from the array base pointer and an index."],["Shl","Returns its first operands bits shifted left by the amount of the 2nd operand. The right input (shift amount) must be an unsigned integer value. If the result mode has modulo_shift!=0, then the effective shift amount is the right input modulo this modulo_shift amount."],["Shr","Returns its first operands bits shifted right by the amount of the 2nd operand. No special handling for the sign bit is performed (zero extension). The right input (shift amount) must be an unsigned integer value. If the result mode has modulo_shift!=0, then the effective shift amount is the right input modulo this modulo_shift amount."],["Shrs","Returns its first operands bits shifted right by the amount of the 2nd operand. The leftmost bit (usually the sign bit) stays the same (sign extension). The right input (shift amount) must be an unsigned integer value. If the result mode has modulo_shift!=0, then the effective shift amount is the right input modulo this modulo_shift amount."],["Size","A symbolic constant that represents the size of a type"],["Start","The first node of a graph. Execution starts with this node."],["Store","Stores a value into memory (heap or stack)."],["Sub","returns the difference of its operands"],["Switch","Change control flow. The destination is chosen based on an integer input value which is looked up in a table."],["Sync","The Sync operation unifies several partial memory blocks. These blocks have to be pairwise disjunct or the values in common locations have to be identical.  This operation allows to specify all operations that eventually need several partial memory blocks as input with a single entrance by unifying the memories with a preceding Sync operation."],["Tuple","Builds a Tuple from single values."],["Unknown","Returns an unknown (at compile- and runtime) value. It is a valid optimization to replace an Unknown by any other constant value."]],"trait":[["BinOp",""],["NodeDebug",""],["NodeTrait","A trait to abstract from Node enum and various *-Node structs. Inspired by https://github.com/libfirm/jFirm/blob/master/src/firm/nodes/Node.java."],["UnaryOp",""],["ValueNode",""]]});