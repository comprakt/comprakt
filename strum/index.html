<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `strum` crate."><meta name="keywords" content="rust, rustlang, rust-lang, strum"><title>strum - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Crate strum</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all strum's items</p></a><div class="block items"><ul><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'strum', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/strum/lib.rs.html#1-671' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>strum</a></span></h1><div class='docblock'><h1 id="strum" class="section-header"><a href="#strum">Strum</a></h1>
<p><a href="https://travis-ci.org/Peternator7/strum"><img src="https://travis-ci.org/Peternator7/strum.svg?branch=master" alt="Build Status" /></a>
<a href="https://crates.io/crates/strum"><img src="https://img.shields.io/crates/v/strum.svg" alt="Latest Version" /></a>
<a href="https://docs.rs/strum"><img src="https://docs.rs/strum/badge.svg" alt="Rust Documentation" /></a></p>
<p>Strum is a set of macros and traits for working with
enums and strings easier in Rust.</p>
<h1 id="including-strum-in-your-project" class="section-header"><a href="#including-strum-in-your-project">Including Strum in Your Project</a></h1>
<p>Import strum and strum_macros into your project by adding the following lines to your
Cargo.toml. Strum_macros contains the macros needed to derive all the traits in Strum.</p>
<pre><code class="language-toml">[dependencies]
strum = &quot;0.11.0&quot;
strum_macros = &quot;0.11.0&quot;
</code></pre>
<p>And add these lines to the root of your project, either lib.rs or main.rs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Strum contains all the trait definitions</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum_macros</span>;</pre></div>
<h1 id="strum-macros" class="section-header"><a href="#strum-macros">Strum Macros</a></h1>
<p>Strum has implemented the following macros:</p>
<ol>
<li>
<p><code>EnumString</code>: auto-derives <code>std::str::FromStr</code> on the enum. Each variant of the enum will match on it's
own name. This can be overridden using <code>serialize=&quot;DifferentName&quot;</code> or <code>to_string=&quot;DifferentName&quot;</code>on the attribute as shown below.
Multiple deserializations can be added to the same variant. If the variant contains additional data,
they will be set to their default values upon deserialization.</p>
<p>The <code>default</code> attribute can be applied to a tuple variant with a single data parameter. When a match isn't
found, the given variant will be returned and the input string will be captured in the parameter.</p>
<p>Here is an example of the code generated by deriving <code>EnumString</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">EnumString</span>)]</span>
<span class="kw">enum</span> <span class="ident">Color</span> {
    <span class="ident">Red</span>,

    <span class="comment">// The Default value will be inserted into range if we match &quot;Green&quot;.</span>
    <span class="ident">Green</span> { <span class="ident">range</span>:<span class="ident">usize</span> },

    <span class="comment">// We can match on multiple different patterns.</span>
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">serialize</span><span class="op">=</span><span class="string">&quot;blue&quot;</span>,<span class="ident">serialize</span><span class="op">=</span><span class="string">&quot;b&quot;</span>)]</span>
    <span class="ident">Blue</span>(<span class="ident">usize</span>),

    <span class="comment">// Notice that we can disable certain variants from being found</span>
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">disabled</span><span class="op">=</span><span class="string">&quot;true&quot;</span>)]</span>
    <span class="ident">Yellow</span>,
}

<span class="comment">/*
//The generated code will look like:
impl ::std::str::FromStr for Color {
    type Err = ::strum::ParseError;

    fn from_str(s: &amp;str) -&gt; ::std::result::Result&lt;Color, Self::Err&gt; {
        match s {
            &quot;Red&quot; =&gt; ::std::result::Result::Ok(Color::Red),
            &quot;Green&quot; =&gt; ::std::result::Result::Ok(Color::Green { range:Default::default() }),
            &quot;blue&quot; | &quot;b&quot; =&gt; ::std::result::Result::Ok(Color::Blue(Default::default())),
            _ =&gt; ::std::result::Result::Err(strum::ParseError::VariantNotFound),
        }
    }
}
*/</span></pre></div>
<p>Note that the implementation of <code>FromStr</code> by default only matches on the name of the
variant. There is an option to match on different case conversions through the
<code>#[strum(serialize_all = &quot;snake_case&quot;)]</code> type attribute. See the <strong>Additional Attributes</strong>
Section for more information on using this feature.</p>
</li>
<li>
<p><code>Display</code>, <code>ToString</code>: both derives print out the given enum variant. This enables you to perform round trip
style conversions from enum into string and back again for unit style variants. <code>ToString</code> and <code>Display</code>
choose which serialization to used based on the following criteria:</p>
<ol>
<li>If there is a <code>to_string</code> property, this value will be used. There can only be one per variant.</li>
<li>Of the various <code>serialize</code> properties, the value with the longest length is chosen. If that
behavior isn't desired, you should use <code>to_string</code>.</li>
<li>The name of the variant will be used if there are no <code>serialize</code> or <code>to_string</code> attributes.</li>
</ol>
<p><strong><code>Display</code> should be preferred to <code>ToString</code>. All types that implement <code>::std::fmt::Display</code> have a default <code>ToString</code> implementation.</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// You need to bring the type into scope to use it!!!</span>
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">string</span>::<span class="ident">ToString</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">Color</span> {
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">serialize</span><span class="op">=</span><span class="string">&quot;redred&quot;</span>)]</span>
    <span class="ident">Red</span>,
    <span class="ident">Green</span> { <span class="ident">range</span>:<span class="ident">usize</span> },
    <span class="ident">Blue</span>(<span class="ident">usize</span>),
    <span class="ident">Yellow</span>,
}

<span class="comment">// It&#39;s simple to iterate over the variants of an enum.</span>
<span class="kw">fn</span> <span class="ident">debug_colors</span>() {
    <span class="kw">let</span> <span class="ident">red</span> <span class="op">=</span> <span class="ident">Color</span>::<span class="ident">Red</span>;
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;redred&quot;</span>), <span class="ident">red</span>.<span class="ident">to_string</span>());
}

<span class="kw">fn</span> <span class="ident">main</span> () { <span class="ident">debug_colors</span>(); }</pre></div>
</li>
<li>
<p><code>AsRefStr</code>: this derive implements <code>AsRef&lt;str&gt;</code> on your enum using the same rules as
<code>ToString</code> for determining what string is returned. The difference is that <code>as_ref()</code> returns
a borrowed <code>str</code> instead of a <code>String</code> so you can save an allocation.</p>
</li>
<li>
<p><code>AsStaticStr</code>: this is similar to <code>AsRefStr</code>, but returns a <code>'static</code> reference to a string which is helpful
in some scenarios. This macro implements <code>strum::AsStaticRef&lt;str&gt;</code> which adds a method <code>.as_static()</code> that
returns a <code>&amp;'static str</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">strum</span>::<span class="ident">AsStaticRef</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">AsStaticStr</span>)]</span>
<span class="kw">enum</span> <span class="ident">State</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">Initial</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>),
    <span class="ident">Finished</span>
}

<span class="kw">fn</span> <span class="ident">print_state</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">s</span>:<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>) {
    <span class="kw">let</span> <span class="ident">state</span> <span class="op">=</span> <span class="ident">State</span>::<span class="ident">Initial</span>(<span class="ident">s</span>);
    <span class="comment">// The following won&#39;t work because the lifetime is incorrect so we can use.as_static() instead.</span>
    <span class="comment">// let wrong: &amp;&#39;static str = state.as_ref();</span>
    <span class="kw">let</span> <span class="ident">right</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span> <span class="op">=</span> <span class="ident">state</span>.<span class="ident">as_static</span>();
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">right</span>);
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="ident">print_state</span>(<span class="kw-2">&amp;</span><span class="string">&quot;hello world&quot;</span>.<span class="ident">to_string</span>())
}</pre></div>
</li>
<li>
<p><code>EnumIter</code>: iterate over the variants of an Enum. Any additional data on your variants will be
set to <code>Default::default()</code>. The macro implements <code>strum::IntoEnumIter</code> on your enum and
creates a new type called <code>YourEnumIter</code> that implements both <code>Iterator</code> and <code>ExactSizeIterator</code>.
You cannot derive <code>EnumIter</code> on any type with a lifetime bound (<code>&lt;'a&gt;</code>) because the iterator would surely
create [unbounded lifetimes] (https://doc.rust-lang.org/nightly/nomicon/unbounded-lifetimes.html).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// You need to bring the type into scope to use it!!!</span>
<span class="kw">use</span> <span class="ident">strum</span>::<span class="ident">IntoEnumIterator</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">EnumIter</span>,<span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">Color</span> {
    <span class="ident">Red</span>,
    <span class="ident">Green</span> { <span class="ident">range</span>:<span class="ident">usize</span> },
    <span class="ident">Blue</span>(<span class="ident">usize</span>),
    <span class="ident">Yellow</span>,
}

<span class="comment">// It&#39;s simple to iterate over the variants of an enum.</span>
<span class="kw">fn</span> <span class="ident">debug_colors</span>() {
    <span class="kw">for</span> <span class="ident">color</span> <span class="kw">in</span> <span class="ident">Color</span>::<span class="ident">iter</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;My favorite color is {:?}&quot;</span>, <span class="ident">color</span>);
    }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="ident">debug_colors</span>();
}</pre></div>
</li>
<li>
<p><code>EnumMessage</code>: encode strings into the enum itself. This macro implements
the <code>strum::EnumMessage</code> trait. <code>EnumMessage</code> looks for
<code>#[strum(message=&quot;...&quot;)]</code> attributes on your variants.
You can also provided a <code>detailed_message=&quot;...&quot;</code> attribute to create a
seperate more detailed message than the first.</p>
<p>The generated code will look something like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// You need to bring the type into scope to use it!!!</span>
<span class="kw">use</span> <span class="ident">strum</span>::<span class="ident">EnumMessage</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">EnumMessage</span>,<span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">Color</span> {
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">message</span><span class="op">=</span><span class="string">&quot;Red&quot;</span>,<span class="ident">detailed_message</span><span class="op">=</span><span class="string">&quot;This is very red&quot;</span>)]</span>
    <span class="ident">Red</span>,
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">message</span><span class="op">=</span><span class="string">&quot;Simply Green&quot;</span>)]</span>
    <span class="ident">Green</span> { <span class="ident">range</span>:<span class="ident">usize</span> },
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">serialize</span><span class="op">=</span><span class="string">&quot;b&quot;</span>,<span class="ident">serialize</span><span class="op">=</span><span class="string">&quot;blue&quot;</span>)]</span>
    <span class="ident">Blue</span>(<span class="ident">usize</span>),
}

<span class="comment">/*
// Generated code
impl ::strum::EnumMessage for Color {
    fn get_message(&amp;self) -&gt; ::std::option::Option&lt;&amp;str&gt; {
        match self {
            &amp;Color::Red =&gt; ::std::option::Option::Some(&quot;Red&quot;),
            &amp;Color::Green {..} =&gt; ::std::option::Option::Some(&quot;Simply Green&quot;),
            _ =&gt; None
        }
    }

    fn get_detailed_message(&amp;self) -&gt; ::std::option::Option&lt;&amp;str&gt; {
        match self {
            &amp;Color::Red =&gt; ::std::option::Option::Some(&quot;This is very red&quot;),
            &amp;Color::Green {..}=&gt; ::std::option::Option::Some(&quot;Simply Green&quot;),
            _ =&gt; None
        }
    }

    fn get_serializations(&amp;self) -&gt; &amp;[&amp;str] {
        match self {
            &amp;Color::Red =&gt; {
                static ARR: [&amp;&#39;static str; 1] = [&quot;Red&quot;];
                &amp;ARR
            },
            &amp;Color::Green {..}=&gt; {
                static ARR: [&amp;&#39;static str; 1] = [&quot;Green&quot;];
                &amp;ARR
            },
            &amp;Color::Blue (..) =&gt; {
                static ARR: [&amp;&#39;static str; 2] = [&quot;b&quot;, &quot;blue&quot;];
                &amp;ARR
            },
        }
    }
}
*/</span></pre></div>
</li>
<li>
<p><code>EnumProperty</code>: Enables the encoding of arbitary constants into enum variants. This method
currently only supports adding additional string values. Other types of literals are still
experimental in the rustc compiler. The generated code works by nesting match statements.
The first match statement matches on the type of the enum, and the inner match statement
matches on the name of the property requested. This design works well for enums with a small
number of variants and properties, but scales linearly with the number of variants so may not
be the best choice in all situations.</p>
<p>Here's an example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// You need to bring the type into scope to use it!!!</span>
<span class="kw">use</span> <span class="ident">strum</span>::<span class="ident">EnumProperty</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">EnumProperty</span>,<span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">Color</span> {
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">props</span>(<span class="ident">Red</span><span class="op">=</span><span class="string">&quot;255&quot;</span>,<span class="ident">Blue</span><span class="op">=</span><span class="string">&quot;255&quot;</span>,<span class="ident">Green</span><span class="op">=</span><span class="string">&quot;255&quot;</span>))]</span>
    <span class="ident">White</span>,
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">props</span>(<span class="ident">Red</span><span class="op">=</span><span class="string">&quot;0&quot;</span>,<span class="ident">Blue</span><span class="op">=</span><span class="string">&quot;0&quot;</span>,<span class="ident">Green</span><span class="op">=</span><span class="string">&quot;0&quot;</span>))]</span>
    <span class="ident">Black</span>,
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">props</span>(<span class="ident">Red</span><span class="op">=</span><span class="string">&quot;0&quot;</span>,<span class="ident">Blue</span><span class="op">=</span><span class="string">&quot;255&quot;</span>,<span class="ident">Green</span><span class="op">=</span><span class="string">&quot;0&quot;</span>))]</span>
    <span class="ident">Blue</span>,
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">props</span>(<span class="ident">Red</span><span class="op">=</span><span class="string">&quot;255&quot;</span>,<span class="ident">Blue</span><span class="op">=</span><span class="string">&quot;0&quot;</span>,<span class="ident">Green</span><span class="op">=</span><span class="string">&quot;0&quot;</span>))]</span>
    <span class="ident">Red</span>,
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">props</span>(<span class="ident">Red</span><span class="op">=</span><span class="string">&quot;0&quot;</span>,<span class="ident">Blue</span><span class="op">=</span><span class="string">&quot;0&quot;</span>,<span class="ident">Green</span><span class="op">=</span><span class="string">&quot;255&quot;</span>))]</span>
    <span class="ident">Green</span>,
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">my_color</span> <span class="op">=</span> <span class="ident">Color</span>::<span class="ident">Red</span>;
    <span class="kw">let</span> <span class="ident">display</span> <span class="op">=</span> <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;My color is {:?}. It&#39;s RGB is {},{},{}&quot;</span>, <span class="ident">my_color</span>
                                           , <span class="ident">my_color</span>.<span class="ident">get_str</span>(<span class="string">&quot;Red&quot;</span>).<span class="ident">unwrap</span>()
                                           , <span class="ident">my_color</span>.<span class="ident">get_str</span>(<span class="string">&quot;Green&quot;</span>).<span class="ident">unwrap</span>()
                                           , <span class="ident">my_color</span>.<span class="ident">get_str</span>(<span class="string">&quot;Blue&quot;</span>).<span class="ident">unwrap</span>());
}</pre></div>
</li>
<li>
<p><code>EnumDiscriminants</code>: Given an enum named <code>MyEnum</code>, generates another enum called
<code>MyEnumDiscriminants</code> with the same variants, without any data fields. This is useful when you
wish to determine the variant of an enum from a String, but the variants contain any
non-<code>Default</code> fields. By default, the generated enum has the following derives:
<code>Clone, Copy, Debug, PartialEq, Eq</code>. You can add additional derives using the
<code>#[strum_discriminants(derive(AdditionalDerive))]</code> attribute.</p>
<p>Here's an example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">

<span class="comment">// Bring trait into scope</span>
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>::<span class="ident">FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">NonDefault</span>;

<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">dead_code</span>)]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">EnumDiscriminants</span>)]</span>
<span class="attribute">#[<span class="ident">strum_discriminants</span>(<span class="ident">derive</span>(<span class="ident">EnumString</span>))]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
    <span class="ident">Variant0</span>(<span class="ident">NonDefault</span>),
    <span class="ident">Variant1</span> { <span class="ident">a</span>: <span class="ident">NonDefault</span> },
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(
        <span class="ident">MyEnumDiscriminants</span>::<span class="ident">Variant0</span>,
        <span class="ident">MyEnumDiscriminants</span>::<span class="ident">from_str</span>(<span class="string">&quot;Variant0&quot;</span>).<span class="ident">unwrap</span>()
    );
}</pre></div>
<p>You can also rename the generated enum using the <code>#[strum_discriminants(name(OtherName))]</code>
attribute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// You need to bring the type into scope to use it!!!</span>
<span class="kw">use</span> <span class="ident">strum</span>::<span class="ident">IntoEnumIterator</span>;

<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">dead_code</span>)]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">EnumDiscriminants</span>)]</span>
<span class="attribute">#[<span class="ident">strum_discriminants</span>(<span class="ident">name</span>(<span class="ident">MyVariants</span>), <span class="ident">derive</span>(<span class="ident">EnumIter</span>))]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
    <span class="ident">Variant0</span>(<span class="ident">bool</span>),
    <span class="ident">Variant1</span> { <span class="ident">a</span>: <span class="ident">bool</span> },
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(
        <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">MyVariants</span>::<span class="ident">Variant0</span>, <span class="ident">MyVariants</span>::<span class="ident">Variant1</span>],
        <span class="ident">MyVariants</span>::<span class="ident">iter</span>().<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;&gt;</span>()
    );
}</pre></div>
<p>The derived enum also has the following trait implementations:</p>
<ul>
<li><code>impl From&lt;MyEnum&gt; for MyEnumDiscriminants</code></li>
<li><code>impl&lt;'_enum&gt; From&lt;&amp;'_enum MyEnum&gt; for MyEnumDiscriminants</code></li>
</ul>
<p>These allow you to get the <em>Discriminants</em> enum variant from the original enum:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum_macros</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">EnumDiscriminants</span>)]</span>
<span class="attribute">#[<span class="ident">strum_discriminants</span>(<span class="ident">name</span>(<span class="ident">MyVariants</span>))]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
    <span class="ident">Variant0</span>(<span class="ident">bool</span>),
    <span class="ident">Variant1</span> { <span class="ident">a</span>: <span class="ident">bool</span> },
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">MyVariants</span>::<span class="ident">Variant0</span>, <span class="ident">MyEnum</span>::<span class="ident">Variant0</span>(<span class="bool-val">true</span>).<span class="ident">into</span>());
}</pre></div>
</li>
</ol>
<h1 id="additional-attributes" class="section-header"><a href="#additional-attributes">Additional Attributes</a></h1>
<p>Strum supports several custom attributes to modify the generated code. At the enum level, the
<code>#[strum(serialize_all = &quot;snake_case&quot;)]</code> attribute can be used to change the case used when
serializing to and deserializing from strings:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum_macros</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>, <span class="ident">ToString</span>)]</span>
<span class="attribute">#[<span class="ident">strum</span>(<span class="ident">serialize_all</span> <span class="op">=</span> <span class="string">&quot;snake_case&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">Brightness</span> {
    <span class="ident">DarkBlack</span>,
    <span class="ident">Dim</span> {
        <span class="ident">glow</span>: <span class="ident">usize</span>,
    },
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">serialize</span> <span class="op">=</span> <span class="string">&quot;bright&quot;</span>)]</span>
    <span class="ident">BrightWhite</span>,
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(
        <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;dark_black&quot;</span>),
        <span class="ident">Brightness</span>::<span class="ident">DarkBlack</span>.<span class="ident">to_string</span>().<span class="ident">as_ref</span>()
    );
    <span class="macro">assert_eq</span><span class="macro">!</span>(
        <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;dim&quot;</span>),
        <span class="ident">Brightness</span>::<span class="ident">Dim</span> { <span class="ident">glow</span>: <span class="number">0</span> }.<span class="ident">to_string</span>().<span class="ident">as_ref</span>()
    );
    <span class="macro">assert_eq</span><span class="macro">!</span>(
        <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;bright&quot;</span>),
        <span class="ident">Brightness</span>::<span class="ident">BrightWhite</span>.<span class="ident">to_string</span>().<span class="ident">as_ref</span>()
    );
}</pre></div>
<p>Custom attributes are applied to a variant by adding <code>#[strum(parameter=&quot;value&quot;)]</code> to the variant.</p>
<ul>
<li>
<p><code>serialize=&quot;...&quot;</code>: Changes the text that <code>FromStr()</code> looks for when parsing a string. This attribute can
be applied multiple times to an element and the enum variant will be parsed if any of them match.</p>
</li>
<li>
<p><code>default=&quot;true&quot;</code>: Applied to a single variant of an enum. The variant must be a Tuple-like
variant with a single piece of data that can be create from a <code>&amp;str</code> i.e. <code>T: From&lt;&amp;str&gt;</code>.
The generated code will now return the variant with the input string captured as shown below
instead of failing.</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="comment">// Replaces this:</span>
<span class="kw">_</span> <span class="op">=&gt;</span> <span class="prelude-val">Err</span>(<span class="ident">strum</span>::<span class="ident">ParseError</span>::<span class="ident">VariantNotFound</span>)
<span class="comment">// With this in generated code:</span>
<span class="ident">default</span> <span class="op">=&gt;</span> <span class="prelude-val">Ok</span>(<span class="ident">Variant</span>(<span class="ident">default</span>.<span class="ident">into</span>()))</pre></div>
<p>The plugin will fail if the data doesn't implement From&lt;&amp;str&gt;. You can only have one <code>default</code>
on your enum.</p>
</li>
<li>
<p><code>disabled=&quot;true&quot;</code>: removes variant from generated code.</p>
</li>
<li>
<p><code>message=&quot;..&quot;</code>: Adds a message to enum variant. This is used in conjunction with the <code>EnumMessage</code>
trait to associate a message with a variant. If <code>detailed_message</code> is not provided,
then <code>message</code> will also be returned when get_detailed_message() is called.</p>
</li>
<li>
<p><code>detailed_message=&quot;..&quot;</code>: Adds a more detailed message to a variant. If this value is omitted, then
<code>message</code> will be used in it's place.</p>
</li>
<li>
<p><code>props(key=&quot;value&quot;)</code>: Used by EnumProperty to add additional information to an enum variant. Multiple
properties can be added in a single nested block.</p>
</li>
</ul>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Using <code>EnumMessage</code> for quickly implementing <code>Error</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum_macros</span>;
<span class="kw">use</span> <span class="ident">strum</span>::<span class="ident">EnumMessage</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">EnumMessage</span>)]</span>
<span class="kw">enum</span> <span class="ident">ServerError</span> {
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">message</span><span class="op">=</span><span class="string">&quot;A network error occured&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">detailed_message</span><span class="op">=</span><span class="string">&quot;Try checking your connection.&quot;</span>)]</span>
    <span class="ident">NetworkError</span>,
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">message</span><span class="op">=</span><span class="string">&quot;User input error.&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">detailed_message</span><span class="op">=</span><span class="string">&quot;There was an error parsing user input. Please try again.&quot;</span>)]</span>
    <span class="ident">InvalidUserInputError</span>,
}

<span class="kw">impl</span> <span class="ident">Display</span> <span class="kw">for</span> <span class="ident">ServerError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span> {
        <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">&quot;{}&quot;</span>, <span class="self">self</span>.<span class="ident">get_message</span>().<span class="ident">unwrap</span>())
    }
}

<span class="kw">impl</span> <span class="ident">Error</span> <span class="kw">for</span> <span class="ident">ServerError</span> {
    <span class="kw">fn</span> <span class="ident">description</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">str</span> {
        <span class="self">self</span>.<span class="ident">get_detailed_message</span>().<span class="ident">unwrap</span>()
    }
}</pre></div>
<p>Using <code>EnumString</code> to tokenize a series of inputs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">strum_macros</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>::<span class="ident">FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Eq</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>, <span class="ident">EnumString</span>)]</span>
<span class="kw">enum</span> <span class="ident">Tokens</span> {
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">serialize</span><span class="op">=</span><span class="string">&quot;fn&quot;</span>)]</span>
    <span class="ident">Function</span>,
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">serialize</span><span class="op">=</span><span class="string">&quot;(&quot;</span>)]</span>
    <span class="ident">OpenParen</span>,
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">serialize</span><span class="op">=</span><span class="string">&quot;)&quot;</span>)]</span>
    <span class="ident">CloseParen</span>,
    <span class="attribute">#[<span class="ident">strum</span>(<span class="ident">default</span><span class="op">=</span><span class="string">&quot;true&quot;</span>)]</span>
    <span class="ident">Ident</span>(<span class="ident">String</span>)
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">toks</span> <span class="op">=</span> [<span class="string">&quot;fn&quot;</span>, <span class="string">&quot;hello_world&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>].<span class="ident">iter</span>()
                   .<span class="ident">map</span>(<span class="op">|</span><span class="ident">tok</span><span class="op">|</span> <span class="ident">Tokens</span>::<span class="ident">from_str</span>(<span class="ident">tok</span>).<span class="ident">unwrap</span>())
                   .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;&gt;</span>();

    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">toks</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">Tokens</span>::<span class="ident">Function</span>,
                          <span class="ident">Tokens</span>::<span class="ident">Ident</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello_world&quot;</span>)),
                          <span class="ident">Tokens</span>::<span class="ident">OpenParen</span>,
                          <span class="ident">Tokens</span>::<span class="ident">CloseParen</span>]);
}</pre></div>
<h1 id="debugging" class="section-header"><a href="#debugging">Debugging</a></h1>
<p>To see the generated code, set the STRUM_DEBUG environment variable before compiling your code.
<code>STRUM_DEBUG=1</code> will dump all of the generated code for every type. <code>STRUM_DEBUG=YourType</code> will
only dump the code generated on a type named YourType.</p>
</div><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.ParseError.html" title='strum::ParseError enum'>ParseError</a></td><td class='docblock-short'><p>The ParseError enum is a collection of all the possible reasons
an enum can fail to parse from a string.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.AsStaticRef.html" title='strum::AsStaticRef trait'>AsStaticRef</a></td><td class='docblock-short'><p>A cheap reference-to-reference conversion. Used to convert a value to a
reference value with <code>'static</code> lifetime within generic code.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.EnumMessage.html" title='strum::EnumMessage trait'>EnumMessage</a></td><td class='docblock-short'><p>Associates additional pieces of information with an Enum. This can be
autoimplemented by deriving <code>EnumMessage</code> and annotating your variants with
`#[strum(message=&quot;...&quot;)].</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.EnumProperty.html" title='strum::EnumProperty trait'>EnumProperty</a></td><td class='docblock-short'><p>EnumProperty is a trait that makes it possible to store additional information
with enum variants. This trait is designed to be used with the macro of the same
name in the <code>strum_macros</code> crate. Currently, the only string literals are supported
in attributes, the other methods will be implemented as additional attribute types
become stabilized.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.IntoEnumIterator.html" title='strum::IntoEnumIterator trait'>IntoEnumIterator</a></td><td class='docblock-short'><p>This trait designates that an <code>Enum</code> can be iterated over. It can
be auto generated using <code>strum_macros</code> on your behalf.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "strum";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>