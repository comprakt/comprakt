//! This is the runtime automatically linked into
//! the compiled mini java file
use libc::{c_int, c_void};
use std::io::{stdin, stdout, Read, Write};

extern "C" {
    // this is the static main function of the minijava
    // program. generated by libfirm, guaranteed to exist.
    pub fn mj_main();
}

pub type MjInt = i32;

macro_rules! mjrt_runtimeexception {
    ($fn_name:ident, $description:expr) => {
        #[no_mangle]
        pub extern "C" fn $fn_name() -> ! {
            use backtrace::Backtrace;
            let bt = Backtrace::new();
            println!("{}\n{:?}", $description, bt);
            unsafe { libc::abort() }
        }
    };
}

mjrt_runtimeexception!(mjrt_dumpstack, "dumpstack");
mjrt_runtimeexception!(mjrt_div_by_zero, "division by zero");
mjrt_runtimeexception!(mjrt_null_usage, "reference is null");
mjrt_runtimeexception!(mjrt_array_out_of_bounds, "array access out of bounds");
mjrt_runtimeexception!(
    mjrt_negative_allocation,
    "cannot allocate less than 0 bytes"
);

#[no_mangle]
pub extern "C" fn mjrt_new(size: i32) -> *mut c_void {
    if size < 0 {
        mjrt_negative_allocation()
    } else if size == 0 {
        0 as *mut c_void
    } else {
        unsafe { libc::calloc(size as usize, 1) }
    }
}

#[no_mangle]
pub extern "C" fn mjrt_system_in_read() -> MjInt {
    let mut byte: [u8; 1] = [0];

    match stdin().read_exact(&mut byte) {
        Ok(()) => i32::from(byte[0]),
        Err(_) => -1,
    }
}

#[no_mangle]
pub extern "C" fn mjrt_system_out_println(num: MjInt) {
    println!("{}", num);
}

#[no_mangle]
pub extern "C" fn mjrt_system_out_write(num: MjInt) {
    unsafe {
        libc::putchar(num as c_int);
    }
}

#[no_mangle]
pub extern "C" fn mjrt_system_out_flush() {
    stdout().flush().ok();
}

#[cfg(not(test))]
#[no_mangle]
pub extern "C" fn main() -> c_int {
    unsafe { mj_main() };
    0
}
