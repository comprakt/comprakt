#![feature(main)]

//! This is the runtime automatically linked into
//! the compiled mini java file
use std::io::{stdin, stdout, Read, Write};

extern "C" {
    // this is the static main function of the minijava
    // program. generated by libfirm, guaranteed to exist.
    pub fn mj_main();
}

pub type MjInt = i32;

macro_rules! mjrt_runtimeexception {
    ($fn_name:ident, $description:expr) => {
        #[no_mangle]
        pub extern "C" fn $fn_name() {
            use backtrace::Backtrace;
            let bt = Backtrace::new();
            println!("{}\n{:?}", $description, bt);
        }
    }
}

mjrt_runtimeexception!(mjrt_dumpstack, "dumpstack");
mjrt_runtimeexception!(mjrt_div_by_zero, "division by zero");
mjrt_runtimeexception!(mjrt_null_usage, "reference is null");
mjrt_runtimeexception!(mjrt_array_out_of_bounds, "array access out of bounds");

#[no_mangle]
pub extern "C" fn mjrt_new() {
    unimplemented!()
}

#[no_mangle]
pub extern "C" fn mjrt_system_in_read() -> MjInt {
    let mut byte: [u8; 1] = [0];

    match stdin().read_exact(&mut byte) {
        Ok(()) => i32::from(byte[0]),
        Err(_) => -1,
    }
}

#[no_mangle]
pub extern "C" fn mjrt_system_out_println(num: MjInt) {
    println!("{}", num);
}

#[no_mangle]
// TODO: this should write a byte. But what's a byte in MiniJava?
pub extern "C" fn mjrt_system_out_write(num: MjInt) {
    print!("{}", num);
}

#[no_mangle]
pub extern "C" fn mjrt_system_out_flush() {
    stdout().flush().ok();
}

#[cfg(not(test))]
#[no_mangle]
pub extern "C" fn main() {
    unsafe { mj_main() };
}
