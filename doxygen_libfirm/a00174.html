<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libFirm: Type System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">libFirm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00174.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Type System</div>  </div>
</div><!--header-->
<div class="contents">

<p>Datastructure to hold type information.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00179"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html">Array</a></td></tr>
<tr class="memdesc:a00179"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array type represents linear arrangement of objects of the same type. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00175"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">Class</a></td></tr>
<tr class="memdesc:a00175"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type opcode is set to type_class the type represents class types. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00182"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00182.html">Code</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00184"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00184.html">Compound</a></td></tr>
<tr class="memdesc:a00184"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions are common to classes, structs and unions, collectively known as "compound types". <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00185"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">Frame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00178"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00178.html">Method</a></td></tr>
<tr class="memdesc:a00178"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method type represents a method, function or procedure type. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00180"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">Pointer</a></td></tr>
<tr class="memdesc:a00180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer types: <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00181"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">Primitive</a></td></tr>
<tr class="memdesc:a00181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive types are types that represent atomic data values that map directly to modes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00186"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00186.html">Segment</a></td></tr>
<tr class="memdesc:a00186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment types represent segments in the object file. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00176"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">Struct</a></td></tr>
<tr class="memdesc:a00176"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct type represents aggregate types that consist of a list of fields. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00187"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html">Traversing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00177"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html">Union</a></td></tr>
<tr class="memdesc:a00177"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union type represents union types. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00183.html">Unknown</a></td></tr>
<tr class="memdesc:a00183"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is an auxiliary type dedicated to support type analyses. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga102a4e613c30d7b6f619451eae9c8297"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga102a4e613c30d7b6f619451eae9c8297">is_SuperClass_of</a>(high, low)&#160;&#160;&#160;<a class="el" href="a00174.html#gac7c09b19601ec011eccd16fff2338b78">is_SubClass_of</a>(low, high)</td></tr>
<tr class="memdesc:ga102a4e613c30d7b6f619451eae9c8297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if high is superclass of low.  <a href="#ga102a4e613c30d7b6f619451eae9c8297">More...</a><br/></td></tr>
<tr class="separator:ga102a4e613c30d7b6f619451eae9c8297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57268250245581d07202dba4f5dc9e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gaa57268250245581d07202dba4f5dc9e2">is_SuperClass_ptr_of</a>(low, high)&#160;&#160;&#160;<a class="el" href="a00174.html#ga2b0b65fe6c45895268a224c9b8f85854">is_SubClass_ptr_of</a>(high, low)</td></tr>
<tr class="memdesc:gaa57268250245581d07202dba4f5dc9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superclass check for pointers to classes.  <a href="#gaa57268250245581d07202dba4f5dc9e2">More...</a><br/></td></tr>
<tr class="separator:gaa57268250245581d07202dba4f5dc9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5b364a10caee62083a7247148e510de8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a></td></tr>
<tr class="memdesc:ga5b364a10caee62083a7247148e510de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type.  <a href="#ga5b364a10caee62083a7247148e510de8">More...</a><br/></td></tr>
<tr class="separator:ga5b364a10caee62083a7247148e510de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5e8200f31821cd2b9d48dbe5abd42752"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga5e8200f31821cd2b9d48dbe5abd42752">tp_opcode</a> { <br/>
&#160;&#160;<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752a0c027cf4b23706855c4a44cd2c356c4a">tpo_uninitialized</a> = 0, 
<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752ada9ceccf0c2a01420fe7458cabc13926">tpo_struct</a>, 
<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752abd15e6878e3fcba190bd127ad18cad9b">tpo_union</a>, 
<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752ab2d06a320c2d47f40b175bb322e213af">tpo_class</a>, 
<br/>
&#160;&#160;<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752ac66542608646732bfa78cde85cf9f568">tpo_segment</a>, 
<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752aa9639c51cfdbd81956dd1100de6df16a">tpo_method</a>, 
<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752a83317ae7130b10a09385c2580dc09924">tpo_array</a>, 
<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752a097b5baf9dcd1679bda0e477f8b7f647">tpo_pointer</a>, 
<br/>
&#160;&#160;<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752a8f298a90aaf1e326b9b1a3f0b3b67c73">tpo_primitive</a>, 
<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752a899be0ce7149c8e6238f79d3470acdac">tpo_code</a>, 
<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752af80327aa2bc16c95ef6d6dc202ba1000">tpo_unknown</a>, 
<a class="el" href="a00174.html#gga5e8200f31821cd2b9d48dbe5abd42752a110e3cc0493869e81dae5f2ee11be92c">tpo_last</a> = tpo_unknown
<br/>
 }</td></tr>
<tr class="memdesc:ga5e8200f31821cd2b9d48dbe5abd42752"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum for the type kinds.  <a href="a00174.html#ga5e8200f31821cd2b9d48dbe5abd42752">More...</a><br/></td></tr>
<tr class="separator:ga5e8200f31821cd2b9d48dbe5abd42752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae765957e7685c3dd8a1d4697dbecaf12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a> { <a class="el" href="a00174.html#ggae765957e7685c3dd8a1d4697dbecaf12a6a7ef334de3606b7187cfa25ad0c93fe">inh_transitive_closure_none</a>, 
<a class="el" href="a00174.html#ggae765957e7685c3dd8a1d4697dbecaf12ae0e836561930284a8084489e2faccc5b">inh_transitive_closure_valid</a>, 
<a class="el" href="a00174.html#ggae765957e7685c3dd8a1d4697dbecaf12aa8ce64760a1e477c8b3af843a65dc906">inh_transitive_closure_invalid</a>, 
<a class="el" href="a00174.html#ggae765957e7685c3dd8a1d4697dbecaf12a8dec26412e7d42f71f4fd38d76fba2b9">inh_transitive_closure_max</a>
 }</td></tr>
<tr class="memdesc:gae765957e7685c3dd8a1d4697dbecaf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of the transitive closure.  <a href="a00174.html#gae765957e7685c3dd8a1d4697dbecaf12">More...</a><br/></td></tr>
<tr class="separator:gae765957e7685c3dd8a1d4697dbecaf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe39f03b8c3fb57a4c60da910d1bc120"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a> { <a class="el" href="a00174.html#ggafe39f03b8c3fb57a4c60da910d1bc120a11a4d315714c880440ab286fe9614e8a">layout_undefined</a>, 
<a class="el" href="a00174.html#ggafe39f03b8c3fb57a4c60da910d1bc120a5c443acd455eab71dec63eb6af580d4f">layout_fixed</a>
 }</td></tr>
<tr class="memdesc:gafe39f03b8c3fb57a4c60da910d1bc120"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of the type layout.  <a href="a00174.html#gafe39f03b8c3fb57a4c60da910d1bc120">More...</a><br/></td></tr>
<tr class="separator:gafe39f03b8c3fb57a4c60da910d1bc120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5760c49c6a29b1f8f8a4269903eef7d9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga5760c49c6a29b1f8f8a4269903eef7d9">get_type_opcode_name</a> (<a class="el" href="a00174.html#ga5e8200f31821cd2b9d48dbe5abd42752">tp_opcode</a> opcode)</td></tr>
<tr class="memdesc:ga5760c49c6a29b1f8f8a4269903eef7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the type opcode <code>opcode</code>.  <a href="#ga5760c49c6a29b1f8f8a4269903eef7d9">More...</a><br/></td></tr>
<tr class="separator:ga5760c49c6a29b1f8f8a4269903eef7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c09b19601ec011eccd16fff2338b78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gac7c09b19601ec011eccd16fff2338b78">is_SubClass_of</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *low, const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *high)</td></tr>
<tr class="memdesc:gac7c09b19601ec011eccd16fff2338b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if low is subclass of high.  <a href="#gac7c09b19601ec011eccd16fff2338b78">More...</a><br/></td></tr>
<tr class="separator:gac7c09b19601ec011eccd16fff2338b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b0b65fe6c45895268a224c9b8f85854"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga2b0b65fe6c45895268a224c9b8f85854">is_SubClass_ptr_of</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *low, <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *high)</td></tr>
<tr class="memdesc:ga2b0b65fe6c45895268a224c9b8f85854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass check for pointers to classes.  <a href="#ga2b0b65fe6c45895268a224c9b8f85854">More...</a><br/></td></tr>
<tr class="separator:ga2b0b65fe6c45895268a224c9b8f85854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04904040f3a16a740150af3bc1f3b0bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga04904040f3a16a740150af3bc1f3b0bb">is_overwritten_by</a> (<a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *high, <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *low)</td></tr>
<tr class="memdesc:ga04904040f3a16a740150af3bc1f3b0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if high is (transitively) overwritten by low.  <a href="#ga04904040f3a16a740150af3bc1f3b0bb">More...</a><br/></td></tr>
<tr class="separator:ga04904040f3a16a740150af3bc1f3b0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3926ad411cd320f2154c8089c508a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga9f3926ad411cd320f2154c8089c508a0">resolve_ent_polymorphy</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *dynamic_class, <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *static_ent)</td></tr>
<tr class="memdesc:ga9f3926ad411cd320f2154c8089c508a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve polymorphism in the inheritance relation.  <a href="#ga9f3926ad411cd320f2154c8089c508a0">More...</a><br/></td></tr>
<tr class="separator:ga9f3926ad411cd320f2154c8089c508a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16754131c6251ed7edd1a9987e7b7a6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga16754131c6251ed7edd1a9987e7b7a6b">set_irp_inh_transitive_closure_state</a> (<a class="el" href="a00174.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a> s)</td></tr>
<tr class="memdesc:ga16754131c6251ed7edd1a9987e7b7a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the transitive closure of sub/superclass state for the whole program.  <a href="#ga16754131c6251ed7edd1a9987e7b7a6b">More...</a><br/></td></tr>
<tr class="separator:ga16754131c6251ed7edd1a9987e7b7a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e917b256d82522ee7e6a6d2f80b265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gaa2e917b256d82522ee7e6a6d2f80b265">invalidate_irp_inh_transitive_closure_state</a> (void)</td></tr>
<tr class="memdesc:gaa2e917b256d82522ee7e6a6d2f80b265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the transitive closure of sub/superclass state for the whole program to <a class="el" href="a00174.html#ggae765957e7685c3dd8a1d4697dbecaf12aa8ce64760a1e477c8b3af843a65dc906" title="Closure invalid, but can be accessed. ">inh_transitive_closure_invalid</a>.  <a href="#gaa2e917b256d82522ee7e6a6d2f80b265">More...</a><br/></td></tr>
<tr class="separator:gaa2e917b256d82522ee7e6a6d2f80b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf33fcadb82ce8e270f883b9eb7cac9c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00174.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gaf33fcadb82ce8e270f883b9eb7cac9c0">get_irp_inh_transitive_closure_state</a> (void)</td></tr>
<tr class="memdesc:gaf33fcadb82ce8e270f883b9eb7cac9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transitive closure of sub/superclass state for the whole program.  <a href="#gaf33fcadb82ce8e270f883b9eb7cac9c0">More...</a><br/></td></tr>
<tr class="separator:gaf33fcadb82ce8e270f883b9eb7cac9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27d16383ec081f3a2567924ca1e89af0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga27d16383ec081f3a2567924ca1e89af0">compute_inh_transitive_closure</a> (void)</td></tr>
<tr class="memdesc:ga27d16383ec081f3a2567924ca1e89af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute transitive closure of the subclass/superclass and overwrites/overwrittenby relation.  <a href="#ga27d16383ec081f3a2567924ca1e89af0">More...</a><br/></td></tr>
<tr class="separator:ga27d16383ec081f3a2567924ca1e89af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a20f7c15b678d852961d0cb4f051f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga6a20f7c15b678d852961d0cb4f051f6c">free_inh_transitive_closure</a> (void)</td></tr>
<tr class="memdesc:ga6a20f7c15b678d852961d0cb4f051f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory occupied by the transitive closure information.  <a href="#ga6a20f7c15b678d852961d0cb4f051f6c">More...</a><br/></td></tr>
<tr class="separator:ga6a20f7c15b678d852961d0cb4f051f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9ad15e24c1119767f2809df5ec8b46b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gaf9ad15e24c1119767f2809df5ec8b46b">get_class_trans_subtype_first</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:gaf9ad15e24c1119767f2809df5ec8b46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start iteration over all transitive subtypes of <code>tp</code>.  <a href="#gaf9ad15e24c1119767f2809df5ec8b46b">More...</a><br/></td></tr>
<tr class="separator:gaf9ad15e24c1119767f2809df5ec8b46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fc7371e55d337890041294aa592146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga37fc7371e55d337890041294aa592146">get_class_trans_subtype_next</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga37fc7371e55d337890041294aa592146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns next type in a subtype iteration started by <a class="el" href="a00174.html#gaf9ad15e24c1119767f2809df5ec8b46b" title="Start iteration over all transitive subtypes of tp. ">get_class_trans_subtype_first()</a>  <a href="#ga37fc7371e55d337890041294aa592146">More...</a><br/></td></tr>
<tr class="separator:ga37fc7371e55d337890041294aa592146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c0e5b73288078e58f43763b1b3ec7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga41c0e5b73288078e58f43763b1b3ec7f">is_class_trans_subtype</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *subtp)</td></tr>
<tr class="memdesc:ga41c0e5b73288078e58f43763b1b3ec7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>subtp</code> is a subtype of <code>tp</code>.  <a href="#ga41c0e5b73288078e58f43763b1b3ec7f">More...</a><br/></td></tr>
<tr class="separator:ga41c0e5b73288078e58f43763b1b3ec7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb8e8af7e1d5025cbed23b833e91414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gaffb8e8af7e1d5025cbed23b833e91414">get_class_trans_supertype_first</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:gaffb8e8af7e1d5025cbed23b833e91414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start iteration over all transitive supertypes of <code>tp</code>.  <a href="#gaffb8e8af7e1d5025cbed23b833e91414">More...</a><br/></td></tr>
<tr class="separator:gaffb8e8af7e1d5025cbed23b833e91414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f32011da7d1ea79084f06ef8cb5fdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga59f32011da7d1ea79084f06ef8cb5fdb">get_class_trans_supertype_next</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga59f32011da7d1ea79084f06ef8cb5fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns next type in a supertype iteration started by <a class="el" href="a00174.html#gaffb8e8af7e1d5025cbed23b833e91414" title="Start iteration over all transitive supertypes of tp. ">get_class_trans_supertype_first()</a>  <a href="#ga59f32011da7d1ea79084f06ef8cb5fdb">More...</a><br/></td></tr>
<tr class="separator:ga59f32011da7d1ea79084f06ef8cb5fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11e5ccb4184a7bb5ae2dcbacdcf83c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gaf11e5ccb4184a7bb5ae2dcbacdcf83c8">get_entity_trans_overwrittenby_first</a> (const <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td></tr>
<tr class="memdesc:gaf11e5ccb4184a7bb5ae2dcbacdcf83c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start iteration over all entities that transitive overwrite entity <code>ent</code>.  <a href="#gaf11e5ccb4184a7bb5ae2dcbacdcf83c8">More...</a><br/></td></tr>
<tr class="separator:gaf11e5ccb4184a7bb5ae2dcbacdcf83c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9266a28d085bd93f6071e6b7fec5e971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga9266a28d085bd93f6071e6b7fec5e971">get_entity_trans_overwrittenby_next</a> (const <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td></tr>
<tr class="memdesc:ga9266a28d085bd93f6071e6b7fec5e971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns next entity in a overwrittenby iteration started by <a class="el" href="a00174.html#gaf11e5ccb4184a7bb5ae2dcbacdcf83c8" title="Start iteration over all entities that transitive overwrite entity ent. ">get_entity_trans_overwrittenby_first()</a>  <a href="#ga9266a28d085bd93f6071e6b7fec5e971">More...</a><br/></td></tr>
<tr class="separator:ga9266a28d085bd93f6071e6b7fec5e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab275dd104b947f651d166ab83df3327e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gab275dd104b947f651d166ab83df3327e">get_entity_trans_overwrites_first</a> (const <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td></tr>
<tr class="memdesc:gab275dd104b947f651d166ab83df3327e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start iteration over all transitive overwritten entities, overwritten by entity <code>ent</code>.  <a href="#gab275dd104b947f651d166ab83df3327e">More...</a><br/></td></tr>
<tr class="separator:gab275dd104b947f651d166ab83df3327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac357442f3d4c844cce8202d25238d21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gac357442f3d4c844cce8202d25238d21b">get_entity_trans_overwrites_next</a> (const <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *ent)</td></tr>
<tr class="memdesc:gac357442f3d4c844cce8202d25238d21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns next entity in a overwrites iteration started by <a class="el" href="a00174.html#gab275dd104b947f651d166ab83df3327e" title="Start iteration over all transitive overwritten entities, overwritten by entity ent. ">get_entity_trans_overwrites_first()</a>  <a href="#gac357442f3d4c844cce8202d25238d21b">More...</a><br/></td></tr>
<tr class="separator:gac357442f3d4c844cce8202d25238d21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918f8d8af4c396f85a78eecd557b1219"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga918f8d8af4c396f85a78eecd557b1219">check_type</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga918f8d8af4c396f85a78eecd557b1219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a type for memory corruption, dangling pointers and consistency.  <a href="#ga918f8d8af4c396f85a78eecd557b1219">More...</a><br/></td></tr>
<tr class="separator:ga918f8d8af4c396f85a78eecd557b1219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644579129332f5be6c17ac058f12b7f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga644579129332f5be6c17ac058f12b7f7">tr_verify</a> (void)</td></tr>
<tr class="memdesc:ga644579129332f5be6c17ac058f12b7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks the type information and performs a set of sanity checks.  <a href="#ga644579129332f5be6c17ac058f12b7f7">More...</a><br/></td></tr>
<tr class="separator:ga644579129332f5be6c17ac058f12b7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5eb65b6cd58eb2fc75c8ef059662bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gae5eb65b6cd58eb2fc75c8ef059662bbf">free_type</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:gae5eb65b6cd58eb2fc75c8ef059662bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the type.  <a href="#gae5eb65b6cd58eb2fc75c8ef059662bbf">More...</a><br/></td></tr>
<tr class="separator:gae5eb65b6cd58eb2fc75c8ef059662bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0d68e3f580aedcda1b031ab1de3376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00174.html#ga5e8200f31821cd2b9d48dbe5abd42752">tp_opcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga0a0d68e3f580aedcda1b031ab1de3376">get_type_opcode</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *type)</td></tr>
<tr class="memdesc:ga0a0d68e3f580aedcda1b031ab1de3376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns opcode of type <code>type</code>.  <a href="#ga0a0d68e3f580aedcda1b031ab1de3376">More...</a><br/></td></tr>
<tr class="separator:ga0a0d68e3f580aedcda1b031ab1de3376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484fbb41a6c1b74177a97e414b501220"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga484fbb41a6c1b74177a97e414b501220">ir_print_type</a> (char *buffer, size_t buffer_size, const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga484fbb41a6c1b74177a97e414b501220"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a string representing the type.  <a href="#ga484fbb41a6c1b74177a97e414b501220">More...</a><br/></td></tr>
<tr class="separator:ga484fbb41a6c1b74177a97e414b501220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08c97f42d1943b24e0125500f5b1f89"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gad08c97f42d1943b24e0125500f5b1f89">get_type_state_name</a> (<a class="el" href="a00174.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a> s)</td></tr>
<tr class="memdesc:gad08c97f42d1943b24e0125500f5b1f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human readable string for the enum entry.  <a href="#gad08c97f42d1943b24e0125500f5b1f89">More...</a><br/></td></tr>
<tr class="separator:gad08c97f42d1943b24e0125500f5b1f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd95acf52505f518c1f2c3c84edfe4f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00174.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gabd95acf52505f518c1f2c3c84edfe4f9">get_type_state</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:gabd95acf52505f518c1f2c3c84edfe4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type layout state of a type.  <a href="#gabd95acf52505f518c1f2c3c84edfe4f9">More...</a><br/></td></tr>
<tr class="separator:gabd95acf52505f518c1f2c3c84edfe4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e99b5b80a5860d7e83f5d3117dec68a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga5e99b5b80a5860d7e83f5d3117dec68a">set_type_state</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, <a class="el" href="a00174.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a> state)</td></tr>
<tr class="memdesc:ga5e99b5b80a5860d7e83f5d3117dec68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type layout state of a type.  <a href="#ga5e99b5b80a5860d7e83f5d3117dec68a">More...</a><br/></td></tr>
<tr class="separator:ga5e99b5b80a5860d7e83f5d3117dec68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b342b998da73f43e5bef27330d52bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00158.html#gabb45fd288af194763a5ff0e3666a4b88">ir_mode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga51b342b998da73f43e5bef27330d52bb">get_type_mode</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga51b342b998da73f43e5bef27330d52bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mode of a type.  <a href="#ga51b342b998da73f43e5bef27330d52bb">More...</a><br/></td></tr>
<tr class="separator:ga51b342b998da73f43e5bef27330d52bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b3df3e5441c49b296bed72face11c9c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga1b3df3e5441c49b296bed72face11c9c">get_type_size</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga1b3df3e5441c49b296bed72face11c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a type in bytes.  <a href="#ga1b3df3e5441c49b296bed72face11c9c">More...</a><br/></td></tr>
<tr class="separator:ga1b3df3e5441c49b296bed72face11c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ded52e7ae5f4513699ca845002fe34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga42ded52e7ae5f4513699ca845002fe34">set_type_size</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, unsigned size)</td></tr>
<tr class="memdesc:ga42ded52e7ae5f4513699ca845002fe34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of a type in bytes.  <a href="#ga42ded52e7ae5f4513699ca845002fe34">More...</a><br/></td></tr>
<tr class="separator:ga42ded52e7ae5f4513699ca845002fe34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81638bb55202986652894c7607858a27"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga81638bb55202986652894c7607858a27">get_type_alignment</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga81638bb55202986652894c7607858a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the alignment of a type in bytes.  <a href="#ga81638bb55202986652894c7607858a27">More...</a><br/></td></tr>
<tr class="separator:ga81638bb55202986652894c7607858a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364627903d39a7b06ab3975ca9d46e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga364627903d39a7b06ab3975ca9d46e74">set_type_alignment</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, unsigned align)</td></tr>
<tr class="memdesc:ga364627903d39a7b06ab3975ca9d46e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the alignment of a type in bytes.  <a href="#ga364627903d39a7b06ab3975ca9d46e74">More...</a><br/></td></tr>
<tr class="separator:ga364627903d39a7b06ab3975ca9d46e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae94fcd0bcf041ebc86534aaad1f3f9"><td class="memItemLeft" align="right" valign="top">ir_visited_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga3ae94fcd0bcf041ebc86534aaad1f3f9">get_type_visited</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga3ae94fcd0bcf041ebc86534aaad1f3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the visited counter of a type.  <a href="#ga3ae94fcd0bcf041ebc86534aaad1f3f9">More...</a><br/></td></tr>
<tr class="separator:ga3ae94fcd0bcf041ebc86534aaad1f3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2376e81d9dbc2cd24e989b6b16b3555e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga2376e81d9dbc2cd24e989b6b16b3555e">set_type_visited</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, ir_visited_t num)</td></tr>
<tr class="memdesc:ga2376e81d9dbc2cd24e989b6b16b3555e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the visited counter of a type to num.  <a href="#ga2376e81d9dbc2cd24e989b6b16b3555e">More...</a><br/></td></tr>
<tr class="separator:ga2376e81d9dbc2cd24e989b6b16b3555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8fd748f6d5580ea9d31a1331c4b9177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gae8fd748f6d5580ea9d31a1331c4b9177">mark_type_visited</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:gae8fd748f6d5580ea9d31a1331c4b9177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets visited field in type to type_visited.  <a href="#gae8fd748f6d5580ea9d31a1331c4b9177">More...</a><br/></td></tr>
<tr class="separator:gae8fd748f6d5580ea9d31a1331c4b9177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dc2f54709325bd2fc70585dbc7e57ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga2dc2f54709325bd2fc70585dbc7e57ca">type_visited</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga2dc2f54709325bd2fc70585dbc7e57ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the type is already visited.  <a href="#ga2dc2f54709325bd2fc70585dbc7e57ca">More...</a><br/></td></tr>
<tr class="separator:ga2dc2f54709325bd2fc70585dbc7e57ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0c9c9ec8d5a5ce82de359c6de51a9d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga3b0c9c9ec8d5a5ce82de359c6de51a9d">get_type_link</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga3b0c9c9ec8d5a5ce82de359c6de51a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated link field of a type.  <a href="#ga3b0c9c9ec8d5a5ce82de359c6de51a9d">More...</a><br/></td></tr>
<tr class="separator:ga3b0c9c9ec8d5a5ce82de359c6de51a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447a11d49ffcef322fb1f99802c0d077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga447a11d49ffcef322fb1f99802c0d077">set_type_link</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, void *l)</td></tr>
<tr class="memdesc:ga447a11d49ffcef322fb1f99802c0d077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the associated link field of a type.  <a href="#ga447a11d49ffcef322fb1f99802c0d077">More...</a><br/></td></tr>
<tr class="separator:ga447a11d49ffcef322fb1f99802c0d077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e2925a2e898b464933e34edb1fd64ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga8e2925a2e898b464933e34edb1fd64ed">inc_master_type_visited</a> (void)</td></tr>
<tr class="memdesc:ga8e2925a2e898b464933e34edb1fd64ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments type visited reference counter by one.  <a href="#ga8e2925a2e898b464933e34edb1fd64ed">More...</a><br/></td></tr>
<tr class="separator:ga8e2925a2e898b464933e34edb1fd64ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73d330c8818a61770cf403b04ce7772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gab73d330c8818a61770cf403b04ce7772">set_master_type_visited</a> (ir_visited_t val)</td></tr>
<tr class="memdesc:gab73d330c8818a61770cf403b04ce7772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets type visited reference counter.  <a href="#gab73d330c8818a61770cf403b04ce7772">More...</a><br/></td></tr>
<tr class="separator:gab73d330c8818a61770cf403b04ce7772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd05dbef3a4e4c962d1567123140442d"><td class="memItemLeft" align="right" valign="top">ir_visited_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gadd05dbef3a4e4c962d1567123140442d">get_master_type_visited</a> (void)</td></tr>
<tr class="memdesc:gadd05dbef3a4e4c962d1567123140442d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type visited reference counter.  <a href="#gadd05dbef3a4e4c962d1567123140442d">More...</a><br/></td></tr>
<tr class="separator:gadd05dbef3a4e4c962d1567123140442d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab3149e6a0a0460f81442777b7bc302b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gaab3149e6a0a0460f81442777b7bc302b">set_type_dbg_info</a> (<a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp, <a class="el" href="a00014.html#ga63247c57676469ec94d1a74f14320014">type_dbg_info</a> *db)</td></tr>
<tr class="memdesc:gaab3149e6a0a0460f81442777b7bc302b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug information of a type.  <a href="#gaab3149e6a0a0460f81442777b7bc302b">More...</a><br/></td></tr>
<tr class="separator:gaab3149e6a0a0460f81442777b7bc302b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838e45ab04c14274ea23acd4f1d431b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00014.html#ga63247c57676469ec94d1a74f14320014">type_dbg_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga838e45ab04c14274ea23acd4f1d431b8">get_type_dbg_info</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga838e45ab04c14274ea23acd4f1d431b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug information of a type.  <a href="#ga838e45ab04c14274ea23acd4f1d431b8">More...</a><br/></td></tr>
<tr class="separator:ga838e45ab04c14274ea23acd4f1d431b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa2cff5265585ccae143da7af1f27574"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#gaaa2cff5265585ccae143da7af1f27574">get_type_nr</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:gaaa2cff5265585ccae143da7af1f27574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a unique number for this type if libfirm is compiled for debugging, (configure with &ndash;enable-debug) else returns the address of the type cast to long.  <a href="#gaaa2cff5265585ccae143da7af1f27574">More...</a><br/></td></tr>
<tr class="separator:gaaa2cff5265585ccae143da7af1f27574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf3ba4c56554c10579c5de11f7a5a2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#ga4cf3ba4c56554c10579c5de11f7a5a2d">is_atomic_type</a> (const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *tp)</td></tr>
<tr class="memdesc:ga4cf3ba4c56554c10579c5de11f7a5a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a type is atomic.  <a href="#ga4cf3ba4c56554c10579c5de11f7a5a2d">More...</a><br/></td></tr>
<tr class="separator:ga4cf3ba4c56554c10579c5de11f7a5a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Datastructure to hold type information. </p>
<p>This module supplies a data structure to represent all types known in the compiled program. This includes types specified in the program as well as types defined by the language. In the view of the intermediate representation there is no difference between these types. Finally it specifies some auxiliary types.</p>
<p>There exist several kinds of types, arranged by the structure of the type. A type is described by a set of attributes. Some of these attributes are common to all types, others depend on the kind of the type.</p>
<p>Types are different from the modes defined in irmode: Types are on the level of the programming language, modes at the level of the target processor. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga102a4e613c30d7b6f619451eae9c8297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define is_SuperClass_of</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">high, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">low&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="a00174.html#gac7c09b19601ec011eccd16fff2338b78">is_SubClass_of</a>(low, high)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if high is superclass of low. </p>
<p>Low is a subclass of high if low == high or if low is a subclass of a subclass of high. I.e, we search in all subtypes of high for low. @@ this can be implemented more efficient if we know the set of all subclasses of high. </p>

<p>Definition at line <a class="el" href="a00124_source.html#l00746">746</a> of file <a class="el" href="a00124_source.html">typerep.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa57268250245581d07202dba4f5dc9e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define is_SuperClass_ptr_of</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">low, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">high&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="a00174.html#ga2b0b65fe6c45895268a224c9b8f85854">is_SubClass_ptr_of</a>(high, low)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Superclass check for pointers to classes. </p>
<p>Dereferences both types the same number of times (as much as possible). If the remaining types are both class types and superclasses, returns true, else false. Can also be called with two class types. </p>

<p>Definition at line <a class="el" href="a00124_source.html#l00753">753</a> of file <a class="el" href="a00124_source.html">typerep.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5b364a10caee62083a7247148e510de8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type. </p>

<p>Definition at line <a class="el" href="a00091_source.html#l00071">71</a> of file <a class="el" href="a00091_source.html">firm_types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gae765957e7685c3dd8a1d4697dbecaf12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00174.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The state of the transitive closure. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggae765957e7685c3dd8a1d4697dbecaf12a6a7ef334de3606b7187cfa25ad0c93fe"></a>inh_transitive_closure_none</em>&#160;</td><td class="fielddoc">
<p>Closure is not computed, can not be accessed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae765957e7685c3dd8a1d4697dbecaf12ae0e836561930284a8084489e2faccc5b"></a>inh_transitive_closure_valid</em>&#160;</td><td class="fielddoc">
<p>Closure computed and valid. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae765957e7685c3dd8a1d4697dbecaf12aa8ce64760a1e477c8b3af843a65dc906"></a>inh_transitive_closure_invalid</em>&#160;</td><td class="fielddoc">
<p>Closure invalid, but can be accessed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae765957e7685c3dd8a1d4697dbecaf12a8dec26412e7d42f71f4fd38d76fba2b9"></a>inh_transitive_closure_max</em>&#160;</td><td class="fielddoc">
<p>Invalid value. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="a00124_source.html#l00786">786</a> of file <a class="el" href="a00124_source.html">typerep.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafe39f03b8c3fb57a4c60da910d1bc120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00174.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The state of the type layout. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggafe39f03b8c3fb57a4c60da910d1bc120a11a4d315714c880440ab286fe9614e8a"></a>layout_undefined</em>&#160;</td><td class="fielddoc">
<p>The layout of this type is not defined. </p>
<p>Address computation to access fields is not possible, fields must be accessed by Sel nodes. This is the default value except for pointer, primitive and method types. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggafe39f03b8c3fb57a4c60da910d1bc120a5c443acd455eab71dec63eb6af580d4f"></a>layout_fixed</em>&#160;</td><td class="fielddoc">
<p>The layout is fixed, all component/member entities have an offset assigned. </p>
<p>Size of the type is known. Arrays can be accessed by explicit address computation. Default for pointer, primitive and method types. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="a00124_source.html#l00891">891</a> of file <a class="el" href="a00124_source.html">typerep.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e8200f31821cd2b9d48dbe5abd42752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00174.html#ga5e8200f31821cd2b9d48dbe5abd42752">tp_opcode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enum for the type kinds. </p>
<p>For each type kind exists a typecode to identify it. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752a0c027cf4b23706855c4a44cd2c356c4a"></a>tpo_uninitialized</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752ada9ceccf0c2a01420fe7458cabc13926"></a>tpo_struct</em>&#160;</td><td class="fielddoc">
<p>A struct type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752abd15e6878e3fcba190bd127ad18cad9b"></a>tpo_union</em>&#160;</td><td class="fielddoc">
<p>A union type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752ab2d06a320c2d47f40b175bb322e213af"></a>tpo_class</em>&#160;</td><td class="fielddoc">
<p>A class type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752ac66542608646732bfa78cde85cf9f568"></a>tpo_segment</em>&#160;</td><td class="fielddoc">
<p>A segment type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752aa9639c51cfdbd81956dd1100de6df16a"></a>tpo_method</em>&#160;</td><td class="fielddoc">
<p>A method type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752a83317ae7130b10a09385c2580dc09924"></a>tpo_array</em>&#160;</td><td class="fielddoc">
<p>An array type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752a097b5baf9dcd1679bda0e477f8b7f647"></a>tpo_pointer</em>&#160;</td><td class="fielddoc">
<p>A pointer type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752a8f298a90aaf1e326b9b1a3f0b3b67c73"></a>tpo_primitive</em>&#160;</td><td class="fielddoc">
<p>A primitive type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752a899be0ce7149c8e6238f79d3470acdac"></a>tpo_code</em>&#160;</td><td class="fielddoc">
<p>a piece of code (a basic block) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752af80327aa2bc16c95ef6d6dc202ba1000"></a>tpo_unknown</em>&#160;</td><td class="fielddoc">
<p>Special code for the Unknown type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e8200f31821cd2b9d48dbe5abd42752a110e3cc0493869e81dae5f2ee11be92c"></a>tpo_last</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="a00124_source.html#l00703">703</a> of file <a class="el" href="a00124_source.html">typerep.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga918f8d8af4c396f85a78eecd557b1219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a type for memory corruption, dangling pointers and consistency. </p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if no errors were found </dd></dl>

</div>
</div>
<a class="anchor" id="ga27d16383ec081f3a2567924ca1e89af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_inh_transitive_closure </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute transitive closure of the subclass/superclass and overwrites/overwrittenby relation. </p>
<p>This function walks over the ir (O(#types+#entities)) to compute the transitive closure. </p>

</div>
</div>
<a class="anchor" id="ga6a20f7c15b678d852961d0cb4f051f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_inh_transitive_closure </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory occupied by the transitive closure information. </p>

</div>
</div>
<a class="anchor" id="gae5eb65b6cd58eb2fc75c8ef059662bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory used by the type. </p>
<p>Removes the type from the type list and frees all entities belonging to the type. </p>

</div>
</div>
<a class="anchor" id="gaf9ad15e24c1119767f2809df5ec8b46b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>* get_class_trans_subtype_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start iteration over all transitive subtypes of <code>tp</code>. </p>

</div>
</div>
<a class="anchor" id="ga37fc7371e55d337890041294aa592146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>* get_class_trans_subtype_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns next type in a subtype iteration started by <a class="el" href="a00174.html#gaf9ad15e24c1119767f2809df5ec8b46b" title="Start iteration over all transitive subtypes of tp. ">get_class_trans_subtype_first()</a> </p>

</div>
</div>
<a class="anchor" id="gaffb8e8af7e1d5025cbed23b833e91414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>* get_class_trans_supertype_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start iteration over all transitive supertypes of <code>tp</code>. </p>

</div>
</div>
<a class="anchor" id="ga59f32011da7d1ea79084f06ef8cb5fdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a>* get_class_trans_supertype_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns next type in a supertype iteration started by <a class="el" href="a00174.html#gaffb8e8af7e1d5025cbed23b833e91414" title="Start iteration over all transitive supertypes of tp. ">get_class_trans_supertype_first()</a> </p>

</div>
</div>
<a class="anchor" id="gab275dd104b947f651d166ab83df3327e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* get_entity_trans_overwrites_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start iteration over all transitive overwritten entities, overwritten by entity <code>ent</code>. </p>

</div>
</div>
<a class="anchor" id="gac357442f3d4c844cce8202d25238d21b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* get_entity_trans_overwrites_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns next entity in a overwrites iteration started by <a class="el" href="a00174.html#gab275dd104b947f651d166ab83df3327e" title="Start iteration over all transitive overwritten entities, overwritten by entity ent. ">get_entity_trans_overwrites_first()</a> </p>

</div>
</div>
<a class="anchor" id="gaf11e5ccb4184a7bb5ae2dcbacdcf83c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* get_entity_trans_overwrittenby_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start iteration over all entities that transitive overwrite entity <code>ent</code>. </p>

</div>
</div>
<a class="anchor" id="ga9266a28d085bd93f6071e6b7fec5e971"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* get_entity_trans_overwrittenby_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns next entity in a overwrittenby iteration started by <a class="el" href="a00174.html#gaf11e5ccb4184a7bb5ae2dcbacdcf83c8" title="Start iteration over all entities that transitive overwrite entity ent. ">get_entity_trans_overwrittenby_first()</a> </p>

</div>
</div>
<a class="anchor" id="gaf33fcadb82ce8e270f883b9eb7cac9c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00174.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a> get_irp_inh_transitive_closure_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the transitive closure of sub/superclass state for the whole program. </p>

</div>
</div>
<a class="anchor" id="gadd05dbef3a4e4c962d1567123140442d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ir_visited_t get_master_type_visited </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns type visited reference counter. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00004.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga81638bb55202986652894c7607858a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned get_type_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the alignment of a type in bytes. </p>

</div>
</div>
<a class="anchor" id="ga838e45ab04c14274ea23acd4f1d431b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00014.html#ga63247c57676469ec94d1a74f14320014">type_dbg_info</a>* get_type_dbg_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the debug information of a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>The type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b0c9c9ec8d5a5ce82de359c6de51a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* get_type_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the associated link field of a type. </p>

</div>
</div>
<a class="anchor" id="ga51b342b998da73f43e5bef27330d52bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00158.html#gabb45fd288af194763a5ff0e3666a4b88">ir_mode</a>* get_type_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mode of a type. </p>
<p>Returns NULL for all non atomic types. </p>

</div>
</div>
<a class="anchor" id="gaaa2cff5265585ccae143da7af1f27574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long get_type_nr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a unique number for this type if libfirm is compiled for debugging, (configure with &ndash;enable-debug) else returns the address of the type cast to long. </p>

</div>
</div>
<a class="anchor" id="ga0a0d68e3f580aedcda1b031ab1de3376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00174.html#ga5e8200f31821cd2b9d48dbe5abd42752">tp_opcode</a> get_type_opcode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns opcode of type <code>type</code>. </p>

</div>
</div>
<a class="anchor" id="ga5760c49c6a29b1f8f8a4269903eef7d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* get_type_opcode_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5e8200f31821cd2b9d48dbe5abd42752">tp_opcode</a>&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the type opcode <code>opcode</code>. </p>

</div>
</div>
<a class="anchor" id="ga1b3df3e5441c49b296bed72face11c9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned get_type_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of a type in bytes. </p>

</div>
</div>
<a class="anchor" id="gabd95acf52505f518c1f2c3c84edfe4f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00174.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a> get_type_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type layout state of a type. </p>

</div>
</div>
<a class="anchor" id="gad08c97f42d1943b24e0125500f5b1f89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* get_type_state_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a human readable string for the enum entry. </p>

</div>
</div>
<a class="anchor" id="ga3ae94fcd0bcf041ebc86534aaad1f3f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ir_visited_t get_type_visited </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the visited counter of a type. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00004.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e2925a2e898b464933e34edb1fd64ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inc_master_type_visited </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments type visited reference counter by one. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00004.html">Visited Counters</a>, <a class="el" href="a00174.html#gae8fd748f6d5580ea9d31a1331c4b9177" title="Sets visited field in type to type_visited. ">mark_type_visited()</a>, <a class="el" href="a00174.html#ga2dc2f54709325bd2fc70585dbc7e57ca" title="Returns non-zero if the type is already visited. ">type_visited()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2e917b256d82522ee7e6a6d2f80b265"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void invalidate_irp_inh_transitive_closure_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the transitive closure of sub/superclass state for the whole program to <a class="el" href="a00174.html#ggae765957e7685c3dd8a1d4697dbecaf12aa8ce64760a1e477c8b3af843a65dc906" title="Closure invalid, but can be accessed. ">inh_transitive_closure_invalid</a>. </p>

</div>
</div>
<a class="anchor" id="ga484fbb41a6c1b74177a97e414b501220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ir_print_type </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct a string representing the type. </p>
<p>This uses the info retrieved by the type_dbg_info if available. Otherwise it tries to create an approximate textual representation of the type. Keep in mind that this representation is not unique for each type, might abstract away some details. The main intention of this is creating human redable strings giving an idea of the type. </p>

</div>
</div>
<a class="anchor" id="ga4cf3ba4c56554c10579c5de11f7a5a2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_atomic_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a type is atomic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>any type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if type is primitive or pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga41c0e5b73288078e58f43763b1b3ec7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_class_trans_subtype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>subtp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if <code>subtp</code> is a subtype of <code>tp</code>. </p>
<p>This function checks the full transitive closure of the subtype relation and not just direct subtyping. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if it is a subtype, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga04904040f3a16a740150af3bc1f3b0bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_overwritten_by </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if high is (transitively) overwritten by low. </p>
<p>Returns false if high == low. </p>

</div>
</div>
<a class="anchor" id="gac7c09b19601ec011eccd16fff2338b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_SubClass_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if low is subclass of high. </p>
<p>Low is a subclass of high if low == high or if low is a subclass of a subclass of high. I.e, we search in all subtypes of high for low. @@ this can be implemented more efficient if we know the set of all subclasses of high. </p>

</div>
</div>
<a class="anchor" id="ga2b0b65fe6c45895268a224c9b8f85854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_SubClass_ptr_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subclass check for pointers to classes. </p>
<p>Dereferences both types the same number of times (as much as possible). If the remaining types are both class types and subclasses, returns true, else false. Can also be called with two class types. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00174.html#gac7c09b19601ec011eccd16fff2338b78" title="Returns true if low is subclass of high. ">is_SubClass_of()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae8fd748f6d5580ea9d31a1331c4b9177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark_type_visited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets visited field in type to type_visited. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00004.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f3926ad411cd320f2154c8089c508a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a>* resolve_ent_polymorphy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>dynamic_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00007.html#ga432640a14055ee444ef07800073673de">ir_entity</a> *&#160;</td>
          <td class="paramname"><em>static_ent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve polymorphism in the inheritance relation. </p>
<p>Returns the dynamically referenced entity if the static entity and the dynamic type are given. Searches downwards in overwritten tree. </p>

</div>
</div>
<a class="anchor" id="ga16754131c6251ed7edd1a9987e7b7a6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_irp_inh_transitive_closure_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#gae765957e7685c3dd8a1d4697dbecaf12">inh_transitive_closure_state</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the transitive closure of sub/superclass state for the whole program. </p>

</div>
</div>
<a class="anchor" id="gab73d330c8818a61770cf403b04ce7772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_master_type_visited </td>
          <td>(</td>
          <td class="paramtype">ir_visited_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets type visited reference counter. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00004.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga364627903d39a7b06ab3975ca9d46e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the alignment of a type in bytes. </p>

</div>
</div>
<a class="anchor" id="gaab3149e6a0a0460f81442777b7bc302b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_dbg_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00014.html#ga63247c57676469ec94d1a74f14320014">type_dbg_info</a> *&#160;</td>
          <td class="paramname"><em>db</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug information of a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>The type. </td></tr>
    <tr><td class="paramname">db</td><td>The debug info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga447a11d49ffcef322fb1f99802c0d077"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the associated link field of a type. </p>

</div>
</div>
<a class="anchor" id="ga42ded52e7ae5f4513699ca845002fe34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of a type in bytes. </p>
<p>For primitive, pointer and method types the size is always fixed. This call is legal but has no effect. </p>

</div>
</div>
<a class="anchor" id="ga5e99b5b80a5860d7e83f5d3117dec68a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00174.html#gafe39f03b8c3fb57a4c60da910d1bc120">ir_type_state</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the type layout state of a type. </p>
<p>For primitives, pointer and method types the layout is always fixed. This call is legal but has no effect. </p>

</div>
</div>
<a class="anchor" id="ga2376e81d9dbc2cd24e989b6b16b3555e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_type_visited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ir_visited_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the visited counter of a type to num. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00004.html">Visited Counters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga644579129332f5be6c17ac058f12b7f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_verify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walks the type information and performs a set of sanity checks. </p>
<dl class="section return"><dt>Returns</dt><dd>0 in case of an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga2dc2f54709325bd2fc70585dbc7e57ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int type_visited </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html#ga5b364a10caee62083a7247148e510de8">ir_type</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero if the type is already visited. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00004.html">Visited Counters</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 2 2019 13:30:36 for libFirm by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
